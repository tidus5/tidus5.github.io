[{"title":"部署hexo admin成功","date":"2021-01-09T10:00:00.000Z","path":"2021/01/09/test123/","text":"haha，我就说测试一下的。哈哈哈 然后发现测试了，没有删除的按钮。。。 emm，就这样吧。 2020年过完了。。。过得很快啊。一整年都不知道干了啥。。 反正全部的记忆，就是疫情，美国大选。 时间过得很快。。 总得做点什么，记录点什么。。。 让时光流逝的有点痕迹。。。","tags":[]},{"title":"jmap中默认MaxNewSize很大的问题","date":"2019-08-30T16:00:40.000Z","path":"2019/08/31/jmap中默认MaxNewSize很大的问题/","text":"用JDK7，在idea直接启动的时候，用jmap -heap pid 查看进程申请的内存的时候，发现一个问题。 ···Heap Configuration: MinHeapFreeRatio = 0 MaxHeapFreeRatio = 100 MaxHeapSize = 4276092928 (4078.0MB) NewSize = 1310720 (1.25MB) MaxNewSize = 17592186044415 MB OldSize = 5439488 (5.1875MB) NewRatio = 2 SurvivorRatio = 8 PermSize = 21757952 (20.75MB) MaxPermSize = 85983232 (82.0MB) G1HeapRegionSize = 0 (0.0MB)···这里MaxNewSize 是一个很大的数，而且格式也不大一样。那这个值是多少呢。 开始以为是显示错了，但除1024除了2次，得出1,677.72感觉数值也不大对。。。 后面搜到 http://www.voidcn.com/article/p-tgdkdxjc-bqp.html 再看了下，知道了是这样回事。 有个关键词Ergonomics。 如果jre 没有设置启动参数，则会用默认参数。 同时，Ergonomics是java 自己会根据实际情况来决定实际采用的参数。 默认值的最大堆大小，是实际内存的1/4，而MaxNewSize，用的是uintx 字段的最大值。 在64位机上，就是2^64的字节，于是算下来就是 17592186044415 MB 然而，实际上，这时候交给Ergonomics 自主选择实际的新生代大小。 所以 jmap显示的，其实并不是最终实际选择的值。 参考： http://www.voidcn.com/article/p-tgdkdxjc-bqp.htmlhttps://www.iteye.com/blog/wangqiaowqo-2146356https://gist.github.com/1363195https://stackoverflow.com/questions/22455562/what-set-the-value-of-jvm-parameter-maxnewsize-ergonomics[jvm 参数默认值(jdk7)]https://my.oschina.net/u/2457218/blog/1544982https://blog.csdn.net/ryo1060732496/article/details/85717553https://blog.csdn.net/weixin_43194122/article/details/91526740","tags":[]},{"title":"idea切换JDK版本的设置","date":"2019-08-29T12:29:11.000Z","path":"2019/08/29/idea切换JDK版本的设置/","text":"有时候，我们使用idea 需要设置不同的JDK版本。 网上可以找到一些设置的教程，在这里做一下个人实验的总结。 简单来说，就是 idea 中设置好两个jdk版本的SDK（选module，按F4然后在 platform setting -&gt; SDKs 里，点加号添加） File -&gt; setting设置，在 Java compiler中，设置module 的Target bytecode version。（1.7 或者1.8） 在项目右键-&gt;open module setting(F4), 左边选择Module，右边切换到 Depencencies，然后在 Dependencies 选择对应的JDK版本。 这里2和3要一致，然后重新build一下，就可以看到生成的class文件的版本已经改变了。 如果是maven项目，pom中的jdk版本设置也会影响到。这个改动后import改动，第二步的设置就会跟随着改变，编译出对应的版本的class文件。··· &lt;java.version&gt;1.8&lt;/java.version&gt;··· 至于怎么看class文件的版本，可以用文本编辑器打开class文件，切换成16进制的模式，看到第一行在cafebabe 后的第一个数字。 如果是34，就是十进制的52，就是jdk8的版本。 33就是十进制的52，就是jdk7的版本。 顺便一说，按F4的Project Structure，左边选Project，这里的设置针对的是Project的默认设置，如果module设置了单独设置就会覆盖这里的。 另外，language level 应该针对的是不同JDK版本的代码格式检查，和编译版本没有关系。 然后， System.getProperty(“java.version”); 这个显示不出class的版本的，他显示的是运行的JRE的版本，这个在Run Configuration里可以设置。","tags":[]},{"title":"JMeter的websocket压测延迟","date":"2019-08-27T11:34:47.000Z","path":"2019/08/27/JMeter的websocket压测延迟/","text":"最近在做WebSocket压测的时候，试用了apache的JMeter。发现一个问题，压力不大的时候，也可能遇到延迟5秒的问题，在此做一下记录。 Jmeter默认不包含WebSocket的测试，需要单独下JMeter的插件。首先到 https://jmeter-plugins.org/install/Install/ 下载JMeter的Plugin Manager。 按照网页上说的，把下载的jar 放到 JMeter 的lib/ext 目录下。重启JMeter。 在Option菜单，点开 Plugin Manager。 在Available Plugins中搜一下，可以看到有两个websocket插件。 WebSocket Sampler by Maciej Zaleski WebSocket Samplers by Peter Doornbosch 开始，我选择安装的是第一个Maciej Zaleski的版本，去他的插件主页可以看到，有好几年没更新了。其实这个插件运行有问题的，会出现压测延迟的问题。所以建议换另一个插件。下面可以不用看了。 JMeter可以切换中文的，在Option下 choose Language 即可选择。 JMeter基本测试，首先需要往Test Plan 下添加线程组。以下对线程组的参数大致做一下解释： 线程数：该线程组包括的线程数； Ramp-up Period（in seconds）：决定在多少秒内启动所有线程，即如果线程数设置为5，而此项设置也设置为5，那么会每隔5/5=1s启动一个线程； 循环次数：即每个线程数要跑测试的次数。如果勾选永远，则会一直循环 （注意：如果勾选了永远且调度器配置中设置了持续时间，则会在持续时间到达之后结束循环） Delay Thread creation until needed（延迟创建线程直到需要）：对超级大线程数可以节约内存 在JMeter 2.7以及更早的版本，测试一启动就会就会创建所有线程（分配内存）， 然后每个线程创建后根据延迟和Ramp-up来暂停执行自己的执行。 那对于超级大的线程数，而且Ramp-up 也分配的很大的测试，就可能一开始创建所有线程就内存不足。 比如，一万的线程数，Ramp-up设置一万秒，每个线程就跑1秒钟。其实永远只有一个线程在执行 勾选后，每个线程到需要时才创建分配内存。避免开始就要分配一万条线程的内存而启动不了。 调度器：勾选此项则打开调度器配置； *持续时间（秒） *：即本线程组测试的持续时间，到时间后则停止此次测试，注意这个时间设置不要设置的比Ramp-up Period（in seconds）小，如果勾选了循环次数中的永远，那么测试一样会在此持续时间到达后结束； *启动延迟（秒） *：此项设置为在我们启动测试后多久时间开始创建线程组，通常用于定时； 设置好基本参数，比如10个线程，3秒内启动完毕，循环300次。总共发送3000条数据。 然后，在线程组下，添加websocket Sampler 取样器。填入测试的IP，端口，发送信息。 在线程组下添加监听器-&gt; 聚合报告 和 查看结果树。 然后点击启动，就可以开始测试了。 这里遇到的问题，是这样10个线程，每个线程发送300条数据。经常会遇到有些消息发送延迟为5秒左右 经过反复测试，都经常会遇到这个问题。 最终试了半天，感觉服务器应该是没问题的。 最终换了个 websocket 插件，就没有遇到这个问题了。 所以，如果有遇到类似问题的，请使用 WebSocket Samplers by Peter Doornbosch 这个插件。 参考资料：https://blog.csdn.net/df0128/article/details/80474252http://jmeter.512774.n5.nabble.com/Delayed-thread-creation-was-OnDemand-ThreadGroup-td5714355.html","tags":[{"name":"JMeter","slug":"JMeter","permalink":"http://yoursite.com/tags/JMeter/"}]},{"title":"关于slf4j log4j log4j2的jar包配合使用的那些事","date":"2017-11-13T06:39:16.000Z","path":"2017/11/13/关于slf4j log4j log4j2的jar包配合使用的那些事/","text":"由于java日志框架众多（common-logging，log4j，slf4j，logback等），引入jar包的时候，就要为其添加对应的日志实现。。 不同的jar包，可能用了不同的日志框架，那引用了之后就得给不同的日志框架添加配置，这个是比较麻烦的。 slf4j就是为了解决这个麻烦事的。 slf4j全称为Simple Logging Facade for JAVA，java简单日志门面。类似于Apache Common-Logging，是对不同日志框架提供的一个门面封装，可以在部署的时候不修改任何配置即可接入一种日志实现方案。但是，他在编译时静态绑定真正的Log库。使用SLF4J时，如果你需要使用某一种日志实现，那么你必须选择正确的SLF4J的jar包的集合（各种桥接包）。 slf4j官网下载地址 这个东西要用图才能说得清楚，借用官网一张图： 下载了slf4j的压缩包后，这里下的版本是slf4j-1.7.25.zip，里面有很多jar文件。 slf4j的核心包是slf4j-api-1.7.25.jar，需要配合日志实现，才能将日志绑定另一种输出。我们先看看slf4j里的jar包的作用. jcl-over-slf4j.jar --&gt; (jcl -&gt; slf4j) 将Jakarta Commons Logging日志框架到 slf4j 的桥接 jul-to-slf4j.jar --&gt; (juc -&gt; slf4j) 将java.util.logging的日志桥接到 slf4j log4j-over-slf4j.jar--&gt; (log4j -&gt; slf4j) 将log4j 的日志，桥接到slf4j osgi-over-slf4j.jar --&gt; (osgi -&gt; slf4j) 将osgi环境下的日志，桥接到slf4j slf4j-android.jar --&gt; (android-&gt; slf4j) 将android环境下的日志，桥接到slf4j slf4j-api.jar --&gt; slf4j 的api接口jar包 slf4j-ext.jar --&gt; 扩展功能 slf4j-jcl.jar --&gt; ( slf4j -&gt; jcl ) slf4j 转接到 Jakarta Commons Logging日志输出框架 slf4j-jdk14.jar --&gt; ( slf4j -&gt; jul ) slf4j 转接到 java.util.logging，所以这个包不能和jul-to-slf4j.jar同时用，否则会死循环！！ slf4j-log4j12.jar --&gt; ( slf4j -&gt; log4j) slf4j 转接到 log4j,所以这个包不能和log4j-over-slf4j.jar同时用，否则会死循环！！ slf4j-migrator.jar --&gt; 一个GUI工具，支持将项目代码中 JCL,log4j,java.util.logging的日志API转换为slf4j的写法 slf4j-nop.jar --&gt; ( slf4j -&gt; null) slf4j的空接口输出绑定，丢弃所有日志输出 slf4j-simple.jar --&gt; ( slf4j -&gt; slf4j-simple ) slf4j的自带的简单日志输出接口 这样整理之后，slf4j的jar包用途就比较清晰了。目前个人遇到的项目里，一般还会有log4j和log4j2混用的问题。因为log4j项目已经停止更新了，官方建议用log4j2。然后，log4j2里也提供了对各类log的桥接支持，这里就只列举相关的几个jar包说明。 log4j-1.2-api.jar --&gt; (log4j -&gt; log4j2) 将log4j 的日志转接到log4j2日志框架 log4j-api.jar --&gt; log4j2的api接口jar包 log4j-core.jar --&gt; ( log4j2 -&gt; log4j-core) log4j2的日志输出核心jar包 log4j-slf4j-impl.jar--&gt; (slf4j -&gt; log4j2) slf4j 转接到 log4j2 的日志输出框架 (不能和 log4j-to-slf4j同时用) log4j-to-slf4j.jar --&gt; ( log4j2 -&gt; slf4j) 将 log4j2的日志桥接到 slf4j (不能和 log4j-slf4j-impl 同时用) 从这里就已经可以看到，日志框架之间的关系有点乱。因为log4j2和slf4j都能对接多种日志框架，所以这些包的依赖，作用，还有命名，都容易让人混淆。 这里针对 log4j, log4j2, slf4j做一个简单总结。log4j 这个最简单，单独使用jar包就一个，已经停止更新，当前最新版是 log4j-1.2.17.jar只有输出功能，没有转接功能。可以用 // PropertyConfigurator.configure(&quot;conf/log4j.properties&quot;); // DOMConfigurator.configure(&quot;conf/log4j.xml&quot;); 来指定配置文件位置。 log4j2 同时有日志输出和转接功能。单独使用时，jar包是 log4j-api-2.x.x.jar 和 log4j-core-2.x.x.jar如果配置文件不在src目录，或者项目build Path 的source目录下，可以用以下代码指定配置文件位置： String config = System.getProperty(&quot;user.dir&quot;);// 获取程序的当前路径 ConfigurationSource source = new ConfigurationSource( new FileInputStream(config + File.separator + &quot;conf&quot; + File.separator + &quot;log4j2.xml&quot;)); Configurator.initialize(null, source); // 以下代码是log4j已经加载配置的情况下，指定加载其他的配置 LoggerContext logContext = (LoggerContext) LogManager.getContext(false); File conFile = new File(&quot;conf/logs/log4j2.xml&quot;); logContext.setConfigLocation(conFile.toURI()); logContext.reconfigure();log4j -&gt; log4j2 桥接 官方说明去掉 log4j 1.x jar，添加log4j-1.2-api.jar，配合 log4j-api-2.x.x.jar 和 log4j-core-2.x.x.jar 即可，依赖如下 log4j-1.2-api.jar log4j-api-2.x.x.jar log4j-core-2.x.x.jarlog4j2 -&gt; log4j 桥接 不建议。本来log4j在2015年停止更新后，就建议转向log4j2，并提供了到log4j2的桥接接口。所以反过来log4j2到log4j是不建议这么做的，log4j2也没有提供直接支持。但理清了上面的jar包作用，就会发现，可以通过 log4j2 -&gt; slf4j -&gt; log4j 的方式来实现。 需要的jar包，根据依赖关系分别是： log4j-api-2.x.x.jar log4j-to-slf4j.jar slf4j-api-x.x.x.jar slf4j-log4j12-x.x.x.jar log4j-1.2.17.jar slf4j 同时有日志输出和转接功能。核心jar包是 slf4j-api-x.x.x.jar因为一般slf4j 只作为桥接用，如果要搭配 slf4j 自带的简单日志输出，那么就加上 slf4j-simple.jar log4j -&gt; slf4j将代码中的log4j日志桥接到 slf4j，需要如下jar包 log4j-over-slf4j-x.x.x.jar slf4j-api-x.x.x.jarlog4j2 -&gt; slf4j将代码中的log4j2日志桥接到 slf4j，需要如下jar包 log4j-api-2.x.x.jar log4j-to-slf4j-2.x.x.jar slf4j-api-x.x.x.jarslf4j -&gt; log4j将slf4j日志，采用log4j实现进行输出，需要如下jar包 slf4j-api-x.x.x.jar slf4j-log4j12.jar log4j-1.2.17.jarslf4j -&gt; log4j2将slf4j日志，采用log4j2实现进行输出，需要如下jar包 slf4j-api-x.x.x.jar log4j-slf4j-impl.jar log4j-api.jar log4j-core.jarslf4j的代理绑定和输出组合起来，就实现了从一种日志框架，转到另一种日志实现框架的效果。建议在这三种日志混用的情况下，采用如下方案 log4j -&gt; log4j2 slf4j -&gt; log4j2最后附上一张3个人的电影","tags":[]},{"title":"hexo添加hexo-math插件以支持LaTeX公式","date":"2016-03-05T16:00:19.000Z","path":"2016/03/06/hexo添加hexo-math插件以支持LaTeX公式/","text":"翻译四圣龙神录的时候，遇到图片里包含了公式的，正好最近在学markdown，而CSDN的md编辑器包含支持LaTeX公式的MathJax插件。但转到自己的Hexo博客，就得单独添加插件了。网上找了点资料，已经有人做好了hexo的MathJax插件了。安装也很简单。可以参考 利用MathJax来渲染LaTeX数学公式进行安装，具体可以去hexo-math github项目页面 看上面有安装方法。 看下效果： $a^2+b^2=c^2$$E=mc^2$ 最近发现一个问题。我的hexo编译有可能出现错误。提示DS.store的 compile 找不到之类的问题。反复参照正确的设置，发现是hexo的版本发生了变化。之前没问题的，是hexo 3.1.1版本。有问题的是hexo 3.2.0版本。安装3.1.1版本的hexo， 用命令npm install hexo@3.1.1， 可以覆盖本地之前安装的3.2.0。可以用 npm ls 查看已安装的组件，安装回hexo 3.1.1 版本，hexo g 就不报错了。这个bug已经有人建立了一个 issue持续关注中。。 hexo作者对这个问题作了回复了。因为.DS.Store 是Mac系统生成的文件，这里直接删掉就行。git rm ./themes/yilia/layout/.DS_Storegit rm ./themes/yilia/layout/_partial/.DS_Storegit commit -am &quot;delete .DS_StoreOK,然后就可以把hexo升级到3.2.0了，直接 npm install hexo 就行。升级之后，hexo g 生成以后如果没有变化，重新hexo g好像不会再全部生成了，有文章修改也只生成修改部分的文件，大大提高生成的速度。https://github.com/hexojs/hexo/issues/1807https://github.com/litten/hexo-theme-yilia/issues/189 PS:官网 上是用的 npm install -g hexo-cli这是全局安装hexo-cli, 然后在blog文件夹执行hexo init 的时候，也会安装到hexo@3.2.0去。npm ls 是查看本地安装的组件， npm ls -g 是查看全局安装的组件。 参考页面：hexo-math 中文说明 （已过时，新的参考插件的github页）玩转hexo博客 添加音乐播放器Node.js安装教程和NPM包管理器使用详解利用MathJax来渲染LaTeX数学公式Mathjax与LaTex公式简介 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"hexo-math","slug":"hexo-math","permalink":"http://yoursite.com/tags/hexo-math/"},{"name":"LaTex","slug":"LaTex","permalink":"http://yoursite.com/tags/LaTex/"},{"name":"MathJax","slug":"MathJax","permalink":"http://yoursite.com/tags/MathJax/"}]},{"title":"hexo用subtree同步主题","date":"2016-01-29T14:54:32.000Z","path":"2016/01/29/hexo用subtree同步主题/","text":"昨天把hexo搭好了以后，改了下主题模板的设置，提交有点问题。太晚了，也就没在意 今天去公司代码更新下来，发现少了点什么。所用的主题文件夹下面是空的。 在github上面看了下，文件夹是灰色的。比如像这个样子 https://www.zhihu.com/question/32213693/answer/55425001 搜了下，是因为直接clone第三方主题，所以其实下面是另一个完整的项目repo。 要同步主题，网上有几种方法。 把.git删掉，这样主题文件夹就变成普通的文件夹了。add 之后，commit 到自己项目就行了。但这样的问题是，没法保持主题的更新，等于是复制了一份到自己的目录。 用git的submodule，在项目的子文件夹里包含子模块。 用git的subtree，也是子文件夹里包含分支项目，但管理上比submodule简单一些，也可同步更新。 网上搜索了一些submodule 和subtree 的资料，虽然还不是很懂，还是考虑用简单的subtree来管理。 具体实施，基本参考这个页面：https://aoxuis.me/bo-ke/2013-08-06-git-subtree 先把主题fork一份到自己账号下，然后这个repo既可以接受原repo的更新，又可以作为自己个人修改的提交。 由于第一次subtree的时候，提示 prefix &apos;themes/yilia&apos; already exists.若只是删除了目录再subtree会提示 Working tree has modifications. Cannot add.所以，本地删掉了yilia目录（先备份config）并提交，保证本地项目干净。 `git rm themes/yilia` `git commit -m &quot;delete yilia&quot;` `git push origin hexo` `git status` `git remote add -f yilia git@github.com:tidus5/hexo-theme-yilia.git` `git subtree add --prefix=themes/yilia yilia master --squash` `git fetch yilia master`然后，最后一条命令执行时报了个错误 `git subtree pull --prefix=themes/yilia/ yilia --squash` `You must provide &lt;repository&gt; &lt;ref&gt;`试了下，在命令中加上具体分支名就行了 `git subtree pull --prefix=themes/yilia yilia master --squash`在使用上，可以就看做是自己项目的一部分（我是这么理解的）。但subtree的部分，也可以单独推送，和获取更新 `$ git commit -a -m &apos;update some&apos;` `$ git subtree push --prefix=themes/yilia/ yilia master` `$ git push origin master # 顺便主项目也 push 了`或者 `git subtree push -P themes/yilia/ yilia master`命令参考： `&apos;git subtree&apos; add -P &lt;prefix&gt; &lt;commit&gt;` `&apos;git subtree&apos; add -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;` `&apos;git subtree&apos; pull -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;` `&apos;git subtree&apos; push -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;` `&apos;git subtree&apos; merge -P &lt;prefix&gt; &lt;commit&gt;` `&apos;git subtree&apos; split -P &lt;prefix&gt; [OPTIONS] [&lt;commit&gt;]`相关参考资料： http://rogerdudler.github.io/git-guide/index.zh.html http://youthyblog.com/2014/06/28/%E4%BD%BF%E7%94%A8github%E7%AE%A1%E7%90%86hexo%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/ http://zipperary.com/2013/05/28/hexo-guide-2/ ============================== http://www.williamsang.com/archives/2284.html http://blog.jysoftware.com/2013/07/git%E7%AE%80%E4%BB%8B%EF%BC%9Asubmodule-subtree/ http://wenku.baidu.com/link?url=ola85Z5tIXJpxCjLTk-dcO81ayXLs68_y6dsmXIa0niF8vWlnAtnEEiZTGlzCNk1G_g36UYNHUBpu9oszONFNB54LNzo3rX7W_ULJg-P-eG http://blog.zlxstar.me/blog/2014/07/18/git-submodule-vs-git-subtree/ https://www.atlassian.com/git/articles/alternatives-to-git-submodule-git-subtree/ http://blog.devtang.com/blog/2013/05/08/git-submodule-issues/ https://qdan.me/list/VOBvIeMuLl7IQHRp https://segmentfault.com/q/1010000000799558 https://hpc.uni.lu/blog/2014/understanding-git-subtree/ https://aoxuis.me/bo-ke/2013-08-06-git-subtree http://havee.me/linux/2012-07/the-git-advanced-subtree.html http://www.cnblogs.com/kidsitcn/p/4541890.html ========================== http://aceking.gitcafe.io/posts/git-submodule.html http://efe.baidu.com/blog/git-submodule-vs-git-subtree/ 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"subtree","slug":"subtree","permalink":"http://yoursite.com/tags/subtree/"}]},{"title":"我的Hexo","date":"2016-01-28T15:47:15.000Z","path":"2016/01/28/我的Hexo/","text":"在网上众多文档和博客中，算是比较顺利的建立好了自己的Hexo博客。apt-get 安装git，也安装了git-core.(并不知道这两个啥差别）安装nodejs，直接去英文主页，安装最新的5.5版本的。gitpages，这个很简单，注册自己用户名一样的项目就行了。记下几个很有帮助的博客资料。 http://jukezhang.com/2014/11/01/construct-blog-with-hexo&amp;&amp;gitcafe/ 换电脑怎么更新博客。(zhihu) http://www.zhihu.com/question/21193762 如何多PC间同步自己的博客。 http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more hexo详细介绍 http://ibruce.info/2013/11/22/hexo-your-blog/ http://jukezhang.com/2014/11/01/construct-blog-with-hexo&amp;&amp;gitcafe/ 可能遇到的问题，比如发布用git还是github。（其实hexo3是用git） http://www.jianshu.com/p/bc81f1737e04 我的Ubuntu用的在线markdown编辑器 http://mahua.jser.me/ 我所用的主题 http://litten.github.io/2014/08/31/hexo-theme-yilia/ 每次修改后 依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 然后才执行hexo generate -d发布网站到master分支上。 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"【四圣龙神录的编程教室】第22章、放炸弹来攻击吧","date":"2015-07-08T17:16:00.000Z","path":"2015/07/09/【四圣龙神录的编程教室】第22章、放炸弹来攻击吧/","text":"原文地址：http://dixq.net/rp/22.html 这次讲炸弹攻击。和往常一样，准备好信息保存的地方，然后进行加载，然后让他自动计算，大概就是这样的感觉就行了。。。在之前的章节里，我们准备了变量来展现特效。之前敌机消灭时，使用了特效。现在在同一个存储区里，加载炸弹的特效看看。之前也说过了，这个特效变量里，加载任何特效都是可以的。以knd作为识别编号的特效，对应的特效被加载后，就那样一直运算的话，那就可以放在同一个存储空间里面了。龙神录的炸弹特效是：“BIU。。。 DON” 这样的一个特效，（这个的编号为1）特效的线条上下左右的移动，（这个的编号为2）从角色身上“咻~”的冒出来的特效，（这个的编号为3）放炸弹的时候，把这些特效的编号分别进行加载，让我们来实现一下吧。首先准备以下的东西。 —————————————————————————————————————————————————————————————————————————— 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;span style=\"font-size:14px;\"&gt;&lt;span style=\"font-size:12px;\"&gt;---- struct.h 添加如下代码 ----//特效typedef struct&#123; int flag,cnt,col,knd,img,eff; double x,y,r,ang,spd,mvang,brt;&#125;effect_t;//炸弹的信息typedef struct&#123; int flag,cnt,knd; double x,y;&#125;bom_t;//画面明暗的信息typedef struct&#123; unsigned char brt;&#125;bright_set_t;//咚！这样的画面摇晃的信息typedef struct&#123; int flag,cnt,time,size; int x,y;&#125;dn_t;---- GV.h 添加如下代码 ----GLOBAL int img_eff_bom[5]; //炸弹的效果的图像GLOBAL bom_t bom; //炸弹GLOBAL bright_set_t bright_set; //绘制的亮度GLOBAL dn_t dn; //咚一下的摇晃---- load.cpp load函数里添加如下代码 ---- img_eff_bom[0] = LoadGraph( \"../dat/img/effect/bom0.png\" ); img_eff_bom[1] = LoadGraph( \"../dat/img/effect/bom1.png\" ); img_eff_bom[2] = LoadGraph( \"../dat/img/char/body.png\" ); img_eff_bom[3] = LoadGraph( \"../dat/img/bullet/bom_title0.png\" ); sound_se[14]=LoadSoundMem(\"../dat/se/bom0.wav\"); sound_se[15]=LoadSoundMem(\"../dat/se/bom1.wav\");---- ini.cpp 的 ini函数里添加如下代码 ---- memset(&amp;bom,0,sizeof(bom_t)); memset(&amp;bright_set,0,sizeof(bright_set_t)); memset(&amp;dn,0,sizeof(dn_t)); bright_set.brt=255;---- out.cpp 的out_main函数改动 ----//碰撞判定的主函数void out_main()&#123; cbom_and_enemy(); cshot_and_enemy(); enemyshot_and_ch();&#125;---- out.cpp 的下面任意地方进行改动 ----//第s个敌人受到炸弹的伤害void hit_enemy(int s,int power)&#123; enemy[s].hp-=power;//根据炸弹的威力，减去对应的HP enemy_death_judge(s);//判断敌机是不是挂了&#125;//炸弹和敌机的处理void cbom_and_enemy()&#123; int s; if(bom.flag!=1)return; for(s=0;s&lt;ENEMY_MAX;s++)&#123;//敌机总数 if(enemy[s].flag&gt;0) hit_enemy(s,ch.power/20);//第s个敌机扣掉ch.power/20的血 &#125;&#125;//自己子弹和敌机的处理void cshot_and_enemy()&#123; int i,s; for(i=0;i&lt;CSHOT_MAX;i++)&#123;//自机子弹的总数 if(cshot[i].flag&gt;0)&#123; for(s=0;s&lt;ENEMY_MAX;s++)&#123;//敌机总数 if(enemy[s].flag&gt;0)&#123; if(out_judge_cshot(i,s))&#123;//自机子弹和敌机发生碰撞的话 cshot[i].flag=0;//把那个自机子弹消除掉 hit_enemy(s,cshot[i].power);//第s个敌机 扣掉 power那么多的血 &#125; &#125; &#125; &#125; &#125;&#125;---- graph.cpp 的 graph_effect 的红字部分进行追加----void graph_effect(int knd)&#123; for(int i=0;i&lt;EFFECT_MAX;i++)&#123; if(effect[i].flag&gt;0 &amp;&amp; effect[i].knd==knd)&#123; if(effect[i].eff==1)//特效是光的话 SetDrawBlendMode( DX_BLENDMODE_ADD, effect[i].brt) ; if(effect[i].eff==2)//特效是α特效的话 SetDrawBlendMode( DX_BLENDMODE_ALPHA, effect[i].brt) ; DrawRotaGraphF(effect[i].x+FIELD_X+dn.x,effect[i].y+FIELD_Y+dn.y,effect[i].r,effect[i].ang,effect[i].img,TRUE); if(effect[i].eff==1 || effect[i].eff==2) SetDrawBlendMode( DX_BLENDMODE_NOBLEND, 0) ; &#125; &#125;&#125;---- graph.cpp 的 graph_main 的改动 ----void graph_main()&#123; if(bright_set.brt!=255)SetDrawBright(bright_set.brt,bright_set.brt,bright_set.brt); graph_back_main();//绘制背景的主函数 graph_effect(0);//敌机死亡的特效 graph_enemy();//敌机的绘制 graph_cshot();//自机子弹的绘制 if(bright_set.brt!=255)SetDrawBright(255,255,255); graph_ch();//自机的绘制 if(bright_set.brt!=255)SetDrawBright(bright_set.brt,bright_set.brt,bright_set.brt); graph_bullet();//子弹的绘制 if(bright_set.brt!=255)SetDrawBright(255,255,255); graph_effect(1);//炸弹的特效 graph_effect(2);//炸弹线的特效 graph_effect(3);//炸弹人物的特效 graph_board();//板子的绘制&#125;&lt;/span&gt;&lt;/span&gt; ——————————————————————————————————————————————————————————————————————————这次在新的构造体里，・保存炸弹信息的bom_t，・保存画面明暗信息的 bright_set_t，・咚！的摇晃画面的信息 dn_t，准备了这三个东西。用 bright_set_t 表示的变量，一般都是255，只有当画面明暗需要变化时才发生变动。 dn_t 这个变量使用方法和以前一样，加载，计算，在画面抖动的时候使用。炸弹的变量的使用方法，都和以前的一样。那么准备工作都做好了。现在就把实际的效果来运算出来看看吧。———————————————————————————————————————————————————————————————————————— 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252&lt;span style=\"font-size:14px;\"&gt;&lt;span style=\"font-size:12px;\"&gt;---- effect.cpp 的改动----#include \"../include/GV.h\"//寻找空的特效编号int search_effect()&#123; for(int i=0;i&lt;EFFECT_MAX;i++)&#123; if(effect[i].flag==0) return i; &#125; return -1;&#125;//对特效进行计算void calc_effect()&#123; for(int i=0;i&lt;EFFECT_MAX;i++)&#123; if(effect[i].flag&gt;0)&#123;//特效已经加载的话 switch(effect[i].knd)&#123;//判断特效的种类 case 0://敌机消灭的特效 effect[i].cnt++; effect[i].r+=0.08;//特效的大小逐渐增大 if(effect[i].cnt&gt;10)//计数到10以上的话 effect[i].brt-=25;//明暗度降低 if(effect[i].cnt&gt;20)//计数到20以上的话 effect[i].flag=0;//消失 break; case 1://炸弹的特效 //坐标计算 effect[i].x+=cos(effect[i].mvang)*effect[i].spd; effect[i].y+=sin(effect[i].mvang)*effect[i].spd; //速度计算 if(effect[i].cnt&lt;60) effect[i].spd-=(0.2+effect[i].cnt*effect[i].cnt/3000.0); if(effect[i].cnt==60)&#123; effect[i].spd=0; se_flag[15]=1; dn.flag=1; dn.cnt=0; dn.size=11; dn.time=20; &#125; //明暗和大小的计算 effect[i].r+=0.015; if(effect[i].cnt&lt;51) effect[i].brt+=5; if(effect[i].cnt&gt;=60)&#123; effect[i].r+=0.04; effect[i].brt-=255/30.0; &#125; //计数增加，和消除的计算 effect[i].cnt++; if(effect[i].cnt&gt;=90) effect[i].flag=0; break; case 2://炸弹特效(文字） //坐标计算 effect[i].x+=cos(effect[i].mvang)*effect[i].spd; effect[i].y+=sin(effect[i].mvang)*effect[i].spd; //明暗计算 if(effect[i].cnt&lt;51) effect[i].brt+=4; if(effect[i].cnt&gt;130-51) effect[i].brt-=4; //计数增加，和消除计算 effect[i].cnt++; if(effect[i].cnt&gt;=130) effect[i].flag=0; break; case 3://炸弹的特效（线条） //坐标计算 effect[i].x+=cos(effect[i].mvang)*effect[i].spd; effect[i].y+=sin(effect[i].mvang)*effect[i].spd; //明暗计算 if(effect[i].cnt&lt;51) effect[i].brt+=2; if(effect[i].cnt&gt;130-51) effect[i].brt-=2; //计数增加，和消除计算 effect[i].cnt++; if(effect[i].cnt&gt;=130) effect[i].flag=0; break; default: printfDx(\"effect设置出错\\n\"); break; &#125; &#125; &#125;&#125;//寻找消灭特效的空编号int search_del_effect()&#123; for(int i=0;i&lt;DEL_EFFECT_MAX;i++)&#123; if(del_effect[i].flag==0) return i; &#125; return -1;&#125;//消灭特效的加载void enter_del_effect(int s)&#123; int k=search_del_effect(); if(k!=-1)&#123; del_effect[k].flag=1;//设置标记 del_effect[k].cnt=0; del_effect[k].col=enemy[s].back_col;//消灭色用敌机的背景色 del_effect[k].x=enemy[s].x;//消灭位置，设置为敌机的位置 del_effect[k].y=enemy[s].y; &#125;&#125;//消灭特效的计算，加载void calc_del_effect()&#123; int k; for(int i=0;i&lt;DEL_EFFECT_MAX;i++)&#123; if(del_effect[i].flag&gt;0)&#123; if(del_effect[i].cnt%2==0)&#123;// 每隔 1/30秒进行设置 if((k=search_effect())!=-1)&#123;//寻找空编号 memset(&amp;effect[k],0,sizeof(effect_t));//初始化 effect[k].flag=1;//设置标记 effect[k].brt=255;//亮度设置为最大值 effect[k].ang=rang(PI);//角度进行随机 effect[k].col=del_effect[i].col;//设置颜色 effect[k].eff=1;//1号是光影特效。设置为光影特效 effect[k].img=img_del_effect[effect[k].col];//设置消除图像 effect[k].knd=0;//特效的种类为0，(消除特效为0号) effect[k].x=del_effect[i].x;//设置坐标 effect[k].y=del_effect[i].y; effect[k].spd=0; &#125; &#125; if(del_effect[i].cnt&gt;8)&#123; del_effect[i].flag=0; &#125; del_effect[i].cnt++; &#125; &#125;&#125;//炸弹的加载void enter_bom()&#123; int k; bom.flag=1; bom.cnt=0; bom.knd=0; ch.mutekicnt=1;//无敌 se_flag[14]=1;//啾~ 的声音 //竖线 if((k=search_effect())!=-1)&#123; effect[k].flag=1; effect[k].cnt=0; effect[k].knd=3;//炸弹的线条的特效 effect[k].brt=0;//α值 effect[k].ang=PI/2;//图像的朝向 effect[k].mvang=-PI/2;//特效前进的方向 effect[k].spd=1;//速度 effect[k].r=1;//大小 effect[k].eff=2;//α混合 effect[k].img=img_eff_bom[3]; effect[k].x=70;//坐标 effect[k].y=300; &#125; //横线 if((k=search_effect())!=-1)&#123; effect[k].flag=1; effect[k].cnt=0; effect[k].knd=3;//炸弹的线条的特效 effect[k].brt=0; effect[k].ang=0; effect[k].mvang=0; effect[k].spd=1; effect[k].r=1; effect[k].eff=2; effect[k].img=img_eff_bom[3]; effect[k].x=100; effect[k].y=350; &#125; //字符 if((k=search_effect())!=-1)&#123; effect[k].flag=1; effect[k].cnt=0; effect[k].knd=2;//炸弹的文字・线的特效 effect[k].brt=0; effect[k].ang=0; effect[k].mvang=-PI/2; effect[k].spd=0.7; effect[k].r=1; effect[k].eff=2; effect[k].img=img_eff_bom[2]; effect[k].x=260; effect[k].y=300; &#125;&#125;//炸弹的计算void bom_calc()&#123; int n,k,shot_angle[4]=&#123;0,PI,PI/2,PI*1.5&#125;;//4发特效飞行的角度 if(ch.flag==0 &amp;&amp; bom.flag==0)&#123;//角色在通常的状态、炸弹在关闭状态的话 if(CheckStatePad(configpad.bom)==1)&#123;//炸弹键被按下的话 enter_bom(); &#125; &#125; if(bom.flag==1)&#123;//炸弹正在释放状态下的话 if(bom.cnt%10==0)&#123;//每1/6秒执行一次 n=(bom.cnt/10); if(n&lt;4 &amp;&amp; (k=search_effect())!=-1)&#123; effect[k].flag=1; effect[k].cnt=0; effect[k].knd=1;//特效编号1：炸弹的特效 effect[k].brt=0; effect[k].ang=rang(PI);//图像的朝向随机 effect[k].mvang=shot_angle[n]-PI/4;//飞行方向 effect[k].spd=13+rang(2);//速度 effect[k].r=0.5;//大小 effect[k].eff=2;//α混合 effect[k].img=img_eff_bom[(bom.cnt/10)/3];//图像 effect[k].x=ch.x;//坐标 effect[k].y=ch.y; &#125; &#125; bom.cnt++; if(bom.cnt&lt;40) bright_set.brt=255-bom.cnt*5;//图像的明暗设定(变暗) if(bom.cnt&gt;90) bright_set.brt=255-40*5+(bom.cnt-90)*5;//图像的明暗设定(变亮) if(bom.cnt&gt;130)&#123; bom.flag=0; bright_set.brt=255; &#125; &#125;&#125;// DUANG 和画面震动的处理void dn_calc()&#123; if(dn.flag==1)&#123; dn.x=(int)rang(dn.size); dn.y=(int)rang(dn.size); dn.cnt++; if(dn.cnt&gt;dn.time)&#123;//到达指定的时间就停止 dn.flag=0; dn.x=0; dn.y=0; &#125; &#125;&#125;void effect_main()&#123; dn_calc();//DUANG 和画面震动的处理 calc_del_effect();//消除特效的计算 calc_effect();//特效的计算 bom_calc();//炸弹的计算&#125;&lt;/span&gt;&lt;/span&gt; ————————————————————————————————————————————————————————————————————————enter_bom 里，炸弹进行加载播放。加载的炸弹在130 个计数内进行计算，进行加载特效，画面的明暗度调整等。 calc_effect()函数是特效的计算函数、添加了对本次新增的1,2,3号特效的处理。 运行结果：http://dixq.net/rp/swf/22.swf (PS: 继续来填坑。。。 公司项目蛋疼。。。照着成功项目换皮，问题是，你皮难看，做出来的东西还不是只能呵呵。。。 结果和原先的相差无几。。。好啦，过两天要考科二了。攒人品啊攒人品。。文字基本是照翻，有啥不通顺的，对照代码看吧。。。 我代码还没仔细看呢。。。） 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第21章、给自机加上碰撞检测和无敌效果吧","date":"2015-05-24T06:50:00.000Z","path":"2015/05/24/【四圣龙神录的编程教室】第21章、给自机加上碰撞检测和无敌效果吧/","text":"原文地址：http://dixq.net/rp/21.html 敌机的碰撞检测以及加上了，这次我们来做自机的碰撞检测吧。首先，在做具体的处理之前，有些准备工作要做。要做子弹的碰撞检测，我们需要知道比如子弹的碰撞判定范围这些信息。那么，我们就像下面这样做。 —————————————————————————————————————————————————————————————————— 123456789101112131415161718192021222324252627282930313233343536373839404142---- struct.h 里添加如下代码 ----//子弹的信息typedef struct&#123; int size_x,size_y,col_num; double range;&#125;bullet_info_t;---- GV.h 里添加如下代码 ----GLOBAL bullet_info_t bullet_info[10];//子弹信息---- load.cpp load函数里添加如下部分 ----sound_se[3]=LoadSoundMem(\"../dat/se/char_death.wav\");//自机死亡音效ChangeVolumeSoundMem( 80, sound_se[3] ) ;---- ini.cpp 里添加如下部分 ----//把传过来的信息放入构造体的函数void input_bullet_info(bullet_info_t *binfo,int size_x,int size_y,int col_num,double range)&#123; binfo-&gt;size_x =size_x; binfo-&gt;size_y =size_y; binfo-&gt;col_num=col_num; binfo-&gt;range =range;&#125;---- ini.cpp first_ini()函数里添加如下部分 ---- //例子：0号子弹是76x76像素，有5种颜色，碰撞范围是17像素 input_bullet_info(&amp;bullet_info[0],76, 76, 5,17.0); input_bullet_info(&amp;bullet_info[1],22, 22, 6, 4.0); input_bullet_info(&amp;bullet_info[2], 5,120,10, 2.5); input_bullet_info(&amp;bullet_info[3],19, 34, 5, 2.0); input_bullet_info(&amp;bullet_info[4],38, 38,10, 2.0); input_bullet_info(&amp;bullet_info[5],14, 16, 3, 3.5); input_bullet_info(&amp;bullet_info[6],14, 18, 3, 2.0); input_bullet_info(&amp;bullet_info[7],16, 16, 9, 2.5); input_bullet_info(&amp;bullet_info[8],12, 18,10, 1.5); input_bullet_info(&amp;bullet_info[9],13, 19, 3, 2.0); ——————————————————————————————————————————————————————————————————first_init 函数里有子弹的信息，我们要花点时间，根据这些信息来制定合适大小的碰撞范围。如果有人觉得这个范围不行，那么就自己试试，调整一下吧。这个函数里，包含了子弹大小，颜色的种类，和碰撞范围等信息。那么，准备工作做好了，现在来看自机的处理吧。话说回来，之前已经做好了一个碰撞检测的模块了，这次也是做同样的判定就行了，比较简单。基本上复制过来就行。虽然存在几个几乎一样的函数感觉不大好，但在这里把它改成通用的函数的话，会不大好理解。函数的通用化以后再讲吧，这里先复制过来稍微改一下下就行了。基本上敌机和自机的碰撞检测是一样的。—————————————————————————————————————————————————————————— 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146---- out.cpp 的改动 ----#include \"../include/GV.h\"#define ENEMY_RANGE_MAX 4#define CSHOT_RANGE_MAX 2#define CRANGE 2.0//敌机的碰撞检测范围int enemy_range[ENEMY_RANGE_MAX]=&#123;16,30,16,50&#125;;//自机子弹的碰撞检测范围int cshot_range[CSHOT_RANGE_MAX]=&#123;6,&#125;;//检测敌机是否和自机子弹发生碰撞int out_judge_cshot(int i,int s)&#123; int j; if(cshot[i].cnt&gt;0)&#123;//对子弹轨道的每一刻的状态都进行计算 double x=cshot[i].x-enemy[s].x;//敌机和自机子弹的距离 double y=cshot[i].y-enemy[s].y; //防止溢出 if(cshot[i].knd&gt;=CSHOT_RANGE_MAX || enemy[s].knd&gt;=ENEMY_RANGE_MAX) printfDx(\"out_judge_cshot OVERFLOW\"); //敌机的碰撞检测范围和自机子弹的碰撞检测范围加起来 double r=cshot_range[cshot[i].knd]+enemy_range[enemy[s].knd]; //如果需要计算其中的过程 if(cshot[i].spd&gt;r)&#123; //储存一帧前的位置 double pre_x=cshot[i].x+cos(cshot[i].angle+PI)*cshot[i].spd; double pre_y=cshot[i].y+sin(cshot[i].angle+PI)*cshot[i].spd; double px,py; for(j=0;j&lt;cshot[i].spd/r;j++)&#123;// 循环（前进距离/碰撞检测大小）次 px=pre_x-enemy[s].x; py=pre_y-enemy[s].y; if(px*px+py*py&lt;r*r) return 1; pre_x+=cos(cshot[i].angle)*r; pre_y+=sin(cshot[i].angle)*r; &#125; &#125; if(x*x+y*y&lt;r*r)//如果在碰撞范围内 return 1;//返回发生碰撞 &#125; return 0;&#125;//判断自机和敌机子弹是否发生碰撞int out_judge_enemyshot(int s,int n)&#123; int j; if(shot[s].bullet[n].cnt&gt;0)&#123;//对子弹轨道的每一刻的状态都进行计算 double x=shot[s].bullet[n].x-ch.x;//敌机和自机子弹的距离 double y=shot[s].bullet[n].y-ch.y; //防止溢出 if(shot[s].bullet[n].knd&gt;=10) printfDx(\"out_judge_enemyshot OVERFLOW\\n\"); //敌机子弹和自机的碰撞判定范围加起来 double r=bullet_info[shot[s].bullet[n].knd].range+CRANGE; //如果需要计算其中的过程 if(shot[s].bullet[n].spd&gt;r)&#123; //保存上一帧的位置 double pre_x=shot[s].bullet[n].x+cos(shot[s].bullet[n].angle+PI)*shot[s].bullet[n].spd; double pre_y=shot[s].bullet[n].y+sin(shot[s].bullet[n].angle+PI)*shot[s].bullet[n].spd; double px,py; for(j=0;j&lt;shot[s].bullet[n].spd/r;j++)&#123;// 循环（前进距离/碰撞检测大小）次 px=pre_x-ch.x; py=pre_y-ch.y; if(px*px+py*py&lt;r*r) return 1; pre_x+=cos(shot[s].bullet[n].angle)*r; pre_y+=sin(shot[s].bullet[n].angle)*r; &#125; &#125; if(x*x+y*y&lt;r*r)//如果在碰撞范围内 return 1;//发生碰撞 &#125; return 0;&#125;extern void enter_del_effect(int);//判断敌机是否死亡void enemy_death_judge(int s)&#123; int i; se_flag[8]=1;//敌机被击中的音效 if(enemy[s].hp&lt;0)&#123;//敌机的HP如果小于0 enemy[s].flag=0;//敌机标记为消灭 se_flag[1]=1;//敌机 BIU 的音效 enter_del_effect(s); for(i=0;i&lt;SHOT_MAX;i++)&#123;//所有子弹数量循环 if(shot[i].flag!=0)&#123;//如果子弹正在显示 if(s==shot[i].num)&#123;//如果是这个敌机发射的子弹 shot[i].flag=2;//设置这个子弹的状态为不再继续 break; &#125; &#125; &#125; &#125;&#125;//自机子弹和敌机的处理void cshot_and_enemy()&#123; int i,s; for(i=0;i&lt;CSHOT_MAX;i++)&#123;//自机子弹的总数 if(cshot[i].flag&gt;0)&#123; for(s=0;s&lt;ENEMY_MAX;s++)&#123;//敌人的总数 if(enemy[s].flag&gt;0)&#123; if(out_judge_cshot(i,s))&#123;//自机子弹和敌机发生碰撞的话 cshot[i].flag=0;//把这个自机子弹标为消失 enemy[s].hp-=cshot[i].power;//根据子弹的威力扣掉敌机相应的HP值 enemy_death_judge(s);//判断敌机是否死亡 &#125; &#125; &#125; &#125; &#125;&#125;//敌机子弹和自机的处理void enemyshot_and_ch()&#123; int s,n; for(s=0;s&lt;SHOT_MAX;s++)&#123;//敌机弹幕的总数 if(shot[s].flag&gt;0)&#123;//如果弹幕正在显示 for(n=0;n&lt;SHOT_BULLET_MAX;n++)&#123;//总子弹数量 if(shot[s].bullet[n].flag==1)&#123;//如果正在显示 if(out_judge_enemyshot(s,n))&#123;//自机如果和那个子弹接触了 shot[s].bullet[n].flag=0;//清除这个子弹 /*决死的炸弹释放，在这里处理*/ if(ch.flag==0 &amp;&amp; ch.mutekicnt==0)&#123;//如果在通常状态，没有处于无敌的情况下 ch.flag =2; //1:检查决死的炸弹 2:死亡动画浮上来 ch.cnt =0; se_flag[3]=1;//BIU 的音效 return; &#125; &#125; &#125; &#125; &#125; &#125;&#125;//碰撞判定的主函数void out_main()&#123; cshot_and_enemy(); enemyshot_and_ch();&#125; enemyshot_and_ch 是敌机的子弹和自机的碰撞判定处理函数，这里出现了一个ch.flag=2的状态呢。被击中后，玩家会进入两个阶段的状态。首先，被击中的瞬间，会进入“可以使用炸弹决死”的状态。 这个状态， 用 ch.flag = 1 来表示。一定时间内没有按下炸弹按键的话，接下来就进入从画面底端往上浮的这个状态。这个状态，用 ch.flag = 2 表示。在画面中上浮的这个状态中，如果有按键输入的话，就会进入最初的状态。另外，角色死后的一段时间，是处于无敌状态的。是否处于无敌状态，由另一个变量表示。ch.mutekicnt不等于0的时候处于无敌状态。这个时候不进行被子弹打中的处理。另外，在 graph函数里绘制时，每两帧只绘制一帧，这样就实现一闪一闪的效果，感觉就像无敌了一样。无敌状态经过一段时间就会消失。那么就让我们来把这些处理和改动来实现一下吧。—————————————————————————————————————————————————————— 12345678910111213141516171819202122232425262728293031323334353637---- char.cpp 的以下函数的改动 ----void calc_ch()&#123; if(ch.cnt==0 &amp;&amp; ch.flag==2)&#123;//这个瞬间死了的话 ch.x=FIELD_MAX_X/2;//设置坐标 ch.y=FIELD_MAX_Y+30; ch.mutekicnt++;//设置无敌状态 &#125; if(ch.flag==2)&#123;//死后重生上浮状态中 unsigned int push=CheckStatePad(configpad.left)+CheckStatePad(configpad.right) +CheckStatePad(configpad.up)+CheckStatePad(configpad.down); ch.y-=1.5;//角色向上移动 //一秒钟以上，或者上移一定距离，或者有键按下的话 if(ch.cnt&gt;60 || (ch.y&lt;FIELD_MAX_Y-20 &amp;&amp; push))&#123; ch.cnt=0; ch.flag=0;//角色的状态恢复原状 &#125; &#125; if(ch.mutekicnt&gt;0)&#123;//无敌的计数不等于0的话 ch.mutekicnt++; if(ch.mutekicnt&gt;120)//2秒以上的话 ch.mutekicnt=0;//重置为0 &#125; ch.cnt++;//角色的计数器自增 ch.img=(ch.cnt%24)/6;//计算选择当期的角色图像&#125;---- graph.cpp 的以下函数的改动 ----//绘制自机void graph_ch()&#123; if(ch.mutekicnt%2==0) DrawRotaGraphF(ch.x+FIELD_X,ch.y+FIELD_Y,1.0f,0.0f,img_ch[0][ch.img],TRUE);&#125; ——————————————————————————————————————————————————————运行结果：http://dixq.net/rp/swf/21.swf 注： 由于制作时的帧率问题，以上的动画中没有很好的表现出角色的闪烁效果。这个动画和实际运行的效果是不一样的。请自己将代码编译运行，确认实际的运行效果。 （PS：上一篇文章翻译都是一年前的了，这半年多没更新了，一个字：懒。要说工作忙也算不上，只是伤心了。项目忙了一段时间，然后测试了一段时间，然后，结果还是不理想，后面干脆砍掉重做。唉，一直不抱希望，对这做出来效果烂的不行的项目。。新的一年，工资也没怎么涨，就这么混着耗下去。。。。唉。。。） 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第20章、我们来绘制背景吧","date":"2014-11-10T16:23:00.000Z","path":"2014/11/11/【四圣龙神录的编程教室】第20章、我们来绘制背景吧/","text":"原文地址：http://dixq.net/rp/20.html 接下来我们来绘制背景吧，来绘制龙神录的第一个舞台吧。虽然说起来有点复杂，我们预先在数据文件里存放一个背景文件的图片快照，把这个滚动起来看看吧。要把背景滚动起来，基本说来就是上下连续的描绘两张一样的图片，把图片大小的周期和滚动的周期调成一样的就行了。 ———————————————————————————————————————————————————————————— 1234567891011121314---- graph_back.cpp 的改动 ----#include \"../include/GV.h\"void graph_back00()&#123; SetDrawArea( 32 , 16 , 416 , 464 ) ;//设置绘制区域 DrawGraph(FIELD_X,count%700+FIELD_Y-700,img_back[0],FALSE); DrawGraph(FIELD_X,count%700+FIELD_Y ,img_back[0],FALSE); SetDrawArea( 0, 0, 640, 480);//返回原来的区域&#125;void graph_back_main()&#123; graph_back00();&#125; ————————————————————————————————————————————————————————————首先，由于要绘制大面积的图像，对不会显示的部分进行计算绘制是不必要的。所以，我们把可能要绘制的部分放到 FIELD 区域里面。然后，把一张图片，在错开一张图片的大小的两个位置上进行绘制，然后以相同的速度进行滚动。这里使用到了每一帧都会增加的 count 变量。额，目前就是一个图片的滚动效果，所以还比较简单啦。———————————————————————————————————————————————————————————————— 123456789101112131415161718192021222324252627282930313233343536373839404142434445---- graph.cpp 的 graph_main 函数里添加如下部分 ----extern void graph_back_main();void graph_main()&#123; graph_back_main();---- GV.h 里加入如下代码 ----GLOBAL int img_back[10];//背景图片GLOBAL int func_state,stage_count,count;---- load.cpp 的 load函数里添加如下部分 ----img_back[0] = LoadGraph(\"../dat/img/back/0/back0.png\");---- main.cpp 的main函数改成如下这样 ---- case 100://通常的处理 calc_ch(); //计算角色 ch_move(); //角色的移动操作 cshot_main();//自机射击的主函数 enemy_main();//敌机的处理的主函数 shot_main(); //射击的主函数 out_main(); //碰撞检测 effect_main();//特效的主函数 graph_main();//绘制的主函数 stage_count++; break;---- main.cpp 里添加如下部分 ---- music_play(); if(CheckStateKey(KEY_INPUT_ESCAPE)==1)break;//如果按下ESC的话，跳出 ScreenFlip();//刷新双缓冲 count++; &#125; DxLib_End();//DxLib的退出处理 return 0;&#125; ————————————————————————————————————————————————————————————————运行结果：http://dixq.net/rp/swf/20.swf （PS：拖延症犯了，本来都烂尾了，看看，这都半年没更了啊。这半年，坚持跑步一个月后，感觉身体不行，去医院检查了之后就没跑了。买了个琴，也没怎么练了。半年，在新公司呆了半年，项目都还没上线，唉。。据说快了吧。反正我就一打酱油的，今天又一个小问题卡了半天。。技术没长进，代码框架不大懂，自己的东西bug一堆。不敢乱改，出错只希望不是我的错，遇到问题就慌了去寻求帮助。。。老大今天一句话说的对啊，没有无缘无故的错误，程序怎么出错的查一下改回来就是了。别说不知道，老总在你后面，你敢说不知道？唉，技术渣的码农啊。。。） 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第19章、给敌机加上消灭特效吧","date":"2014-04-02T14:50:00.000Z","path":"2014/04/02/【四圣龙神录的编程教室】第19章、给敌机加上消灭特效吧/","text":"原文地址：http://dixq.net/rp/19.html 敌机就只是突然消失的话，感觉少了点什么，我们来给他加上消灭的特效吧。那么首先，我们把特效需要用到的一个文件添加进来。在解决方案资源管理器里，项目上点击右键，添加项，选择 mydat 文件夹的 source 里的 effect.cpp 加入。在里面复制下面的内容粘贴进去。 ———————————————————————————————————————————————————————————————————— 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586---- effect.cpp ----#include \"../include/GV.h\"//寻找空的特效存放位置int search_effect()&#123; for(int i=0;i&lt;EFFECT_MAX;i++)&#123; if(effect[i].flag==0) return i; &#125; return -1;&#125;//计算特效void calc_effect()&#123; for(int i=0;i&lt;EFFECT_MAX;i++)&#123; if(effect[i].flag&gt;0)&#123;//特效已经注册了的话 switch(effect[i].knd)&#123;//根据特效的种类进行分支处理 case 0://0番の処理 effect[i].cnt++; effect[i].r+=0.08; //特效的大小逐渐变大 if(effect[i].cnt&gt;10) //过了10帧的话 effect[i].brt-=25; //明亮程度减少 if(effect[i].cnt&gt;20) //过了20帧的话 effect[i].flag=0; //消失 break; default: printfDx(\"effect設定エラー\\n\"); break; &#125; &#125; &#125;&#125;//寻找消灭特效的空的存放位置int search_del_effect()&#123; for(int i=0;i&lt;DEL_EFFECT_MAX;i++)&#123; if(del_effect[i].flag==0) return i; &#125; return -1;&#125;//消灭特效的注册void enter_del_effect(int s)&#123; int k=search_del_effect(); if(k!=-1)&#123; del_effect[k].flag=1; //设置标志 del_effect[k].cnt=0; del_effect[k].col=enemy[s].back_col; //消除颜色设定为敌机的背景色 del_effect[k].x=enemy[s].x; //消灭位置设定为敌机的坐标 del_effect[k].y=enemy[s].y; &#125;&#125;//消灭特效的计算和特效的注册void calc_del_effect()&#123; int k; for(int i=0;i&lt;DEL_EFFECT_MAX;i++)&#123; if(del_effect[i].flag&gt;0)&#123; if(del_effect[i].cnt%2==0)&#123; // 每1/30秒进行设置 if((k=search_effect())!=-1)&#123; //寻找空的编号 memset(&amp;effect[k],0,sizeof(effect_t)); //初始化 effect[k].flag=1; //设置标记 effect[k].brt=255; //亮度设为最大值 effect[k].ang=rang(PI); //设置随机的角度 effect[k].col=del_effect[i].col; //设置颜色 effect[k].eff=1; //1号是光的特效。这里设置为光特效 effect[k].img=img_del_effect[effect[k].col]; //设置消灭的图像 effect[k].knd=0; //特效的种类是0号(消灭特效是0) effect[k].x=del_effect[i].x;//设置坐标 effect[k].y=del_effect[i].y; &#125; &#125; if(del_effect[i].cnt&gt;8)&#123; //计数比8大的话，就结束 del_effect[i].flag=0; &#125; del_effect[i].cnt++; &#125; &#125;&#125;void effect_main()&#123; calc_del_effect(); //计算消除特效 calc_effect(); //计算特效&#125; ——————————————————————————————————————————————————————————————————————————enter_del_effect 里消除特效注册了的话，然后就是全自动的对特效进行计算，十分方便。这个函数里，参数s 传入的是敌机的识别编号。这样，s号敌机消灭后特效就进行注册。这次也是准备了新的数据存放的地方。消除特效存放在 del_effect特效存在 effect 里为什么要准备消除特效和普通特效这样两种呢，也许有人在想这个问题。消除特效不仅仅是实际特效的播放，还要管理什么时候特效登陆，什么样的特效登陆等信息。 （译者注：个人理解，就是弹幕和子弹的关系。这里消除特效是由特效组成的）总之，就是实际的特效是 effect 的计算，绘制。这个effect 变量 是一个通用的东西，除了消除特效，还能展示各种各样的东西。从此特效里可以放各种各样的东西，几乎都在这了。各种各样的特效要使用的话，就要准备各种各样的变量，这样太麻烦了所以我们采用更有效率的方法。所以，目前要记住这点，“消除特效的变量上，承载着特效变量。只有消除特效变量的话，是不能成为特效的。消除特效变量，是做特效的管理工作这样的事情的”。enter_del_effect 函数里注册了的信息，在 calc_del_effect() 函数里进行计算。看了注释应该就能明白，寻找注册了的消除特效，如果有，就每1/30 秒注册一个特效。然后，寻找特效的注册编号，在那里设置信息。之前也说了，特效变量可以用在任何方面，在表示什么样的特效的种类 knd里代入0。以后消除特效就是0号的特效了。 out_main 里，自机射击总数和敌机总数进行全部的碰撞判定。那么这里也要添加如下的改动。———————————————————————————————————————————————————————————————————————— 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118---- out.cpp 做出如下改动 ----extern void enter_del_effect(int);//这是新加的void enemy_death_judge(int s)&#123; int i; se_flag[8]=1; //敌机被击中的音效 if(enemy[s].hp&lt;0)&#123; //敌机的HP小于0的话 enemy[s].flag=0; //敌机消除 se_flag[1]=1; //敌机的BIU的音效 enter_del_effect(s);//这是新加的---- define.h 添加如下代码 ----//特效的最大数目#define EFFECT_MAX 100//消除特效的最大数目#define DEL_EFFECT_MAX 30---- struct.h 做出以下改动 ----//敌机相关的构造体typedef struct&#123; int flag,cnt,pattern,muki,knd,hp,hp_max,item_n[6],img,back_col; //背景色是新加的 //标志，计数，移动模式，方向，敌机的种类，HP的最大值，掉落的道具，背景色 double x,y,vx,vy,sp,ang; //坐标，速度的x分量，速度的y分量，速度，角度 int bltime,blknd,blknd2,col,state,wtime,wait; //弹幕的开始时间，弹幕的种类，子弹的种类，颜色，状态，待机时间，停滞时间&#125;enemy_t;---- enemy.cpp 的 enemy_enter函数的登陆部分里添加如下代码 ----enemy[i].back_col=GetRand(4);---- function.h 里添加如下代码 ----//effect.cppGLOBAL void effect_main();---- GV.h 里添加如下代码 ----GLOBAL int img_del_effect[5];GLOBAL del_effect_t del_effect[DEL_EFFECT_MAX]; //消灭特效GLOBAL effect_t effect[EFFECT_MAX]; //特效---- ini.cpp 的 ini函数里添加如下代码 ----memset(effect,0,sizeof(effect_t)*EFFECT_MAX);memset(del_effect,0,sizeof(del_effect_t)*DEL_EFFECT_MAX);---- load.cpp 的 load函数里添加如下代码 ----LoadDivGraph( \"../dat/img/enemy/hit_effect.png\" , 5 , 5 , 1 , 140 , 140 , img_del_effect ) ;---- main.cpp 的main函数里添加如下代码 ---- case 100: //通常处理 calc_ch(); //角色计算 ch_move(); //角色的移动操作 cshot_main();//自机射击的主函数 enemy_main();//敌机处理的主函数 shot_main(); //射击的主函数 out_main(); //碰撞检测 effect_main();//特效主函数，这是新加的 graph_main();//绘画主函数 stage_count++; break;---- struct.h 里添加如下代码 ----//特效typedef struct&#123; int flag,cnt,col,knd,img,eff,brt; double x,y,r,ang;&#125;effect_t;//消除特效typedef struct&#123; int flag,cnt,col; double x,y;&#125;del_effect_t;---- graph.cpp 里添加如下代码 ----//这段都是新加的void graph_effect()&#123; for(int i=0;i&lt;EFFECT_MAX;i++)&#123; if(effect[i].flag&gt;0)&#123; if(effect[i].eff==1) //特效是光特效的话 SetDrawBlendMode( DX_BLENDMODE_ADD, effect[i].brt) ; DrawRotaGraphF(effect[i].x+FIELD_X,effect[i].y+FIELD_Y,effect[i].r,effect[i].ang,effect[i].img,TRUE); if(effect[i].eff==1) SetDrawBlendMode( DX_BLENDMODE_NOBLEND, 0) ; &#125; &#125;&#125;void graph_main()&#123; graph_effect(); //新加的特效绘制 graph_enemy(); graph_cshot(); graph_ch(); graph_bullet(); graph_board();&#125; 运行结果： http://dixq.net/rp/swf/19.swf 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第18章、给自机的子弹加上碰撞检测吧","date":"2014-03-15T06:17:00.000Z","path":"2014/03/15/【四圣龙神录的编程教室】第18章、给自机的子弹加上碰撞检测吧/","text":"原文地址：http://dixq.net/rp/18.html 这次的内容是碰撞检测相关的方面。做过STG的人的话，可能会说“用勾股定理就轻松搞定了啦”这样的观点。但当子弹的射速比较快的时候，只用那个就可能不行了。如果对和碰撞检测相关的用勾股定理判定的方法不太清楚的话，到游戏编程馆里的第s11章去看一下先吧。 看这里假设碰撞检测的有效范围是10，子弹的速度是100的话，会怎么样呢？子弹每次会移动100的距离，但碰撞检测只能对那10 的范围进行检测，也就是说，子弹在高速移动的话，会有检测不到的地方。因此，有可能发生敌人直接穿过自机的子弹的情况。为了避免这样的情况，要对自机子弹通过的地方，一点一点的进行检查，必须要保证没有遗漏的地方。那么，啰嗦了这么多，我们就按如下步骤进行实现吧。在out_judge_cshot 函数里，把传进来的 i 号的自机子弹， 和 s 号的敌机进行碰撞检测，＞if(cshot[i].cnt&gt;0){也就是说，一旦计算了子弹的轨道，要回到一帧以前的位置开始，一点一点的让子弹飞向现在的位置，同时判断子弹和敌机是否发生碰撞，这样对每一部都进行检测才行。实现过程如下。（睡觉先，2:39了） ———————————————————————————————————————————————————————————————————————— 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879---- out.cpp を変更 ----#include \"../include/GV.h\"#define ENEMY_RANGE_MAX 4#define CSHOT_RANGE_MAX 2//敌机的碰撞检测范围int enemy_range[ENEMY_RANGE_MAX]=&#123;16,30,16,50&#125;;//自机的子弹的碰撞检测范围int cshot_range[CSHOT_RANGE_MAX]=&#123;6,&#125;;//判断是否发生碰撞int out_judge_cshot(int i,int s)&#123; int j; if(cshot[i].cnt&gt;0)&#123;//每一帧都对子弹的轨道进行计算 double x=cshot[i].x-enemy[s].x;//敌机和自机子弹的距离 double y=cshot[i].y-enemy[s].y; //超界的判断 if(cshot[i].knd&gt;=CSHOT_RANGE_MAX || enemy[s].knd&gt;=ENEMY_RANGE_MAX) printfDx(\"out_judge_cshot内オーバーフロー\"); //敌机的判定和自己子弹判定的加起来的范围 double r=cshot_range[cshot[i].knd]+enemy_range[enemy[s].knd]; //如果需要中间计算 if(cshot[i].spd&gt;r)&#123; //保存下前一帧所在的位置 double pre_x=cshot[i].x+cos(cshot[i].angle+PI)*cshot[i].spd; double pre_y=cshot[i].y+sin(cshot[i].angle+PI)*cshot[i].spd; double px,py; for(j=0;j&lt;cshot[i].spd/r;j++)&#123;//前进的部分除以碰撞判定的部分，循环这么多次 px=pre_x-enemy[s].x; py=pre_y-enemy[s].y; if(px*px+py*py&lt;r*r) return 1; pre_x+=cos(cshot[i].angle)*r; pre_y+=sin(cshot[i].angle)*r; &#125; &#125; if(x*x+y*y&lt;r*r)//检测在碰撞内的话 return 1;//碰撞 &#125; return 0;&#125;//判断敌机是否死亡void enemy_death_judge(int s)&#123; int i; se_flag[8]=1;//敌机被打中的音效 if(enemy[s].hp&lt;0)&#123;//敌机的血量小于0的话 enemy[s].flag=0;//让敌机消失 se_flag[1]=1;//敌机的 BIU 的音效 for(i=0;i&lt;SHOT_MAX;i++)&#123;//遍历所有的弹幕 if(shot[i].flag!=0)&#123;//如果有注册了的弹幕数据 if(s==shot[i].num)&#123;//如果这个弹幕是这个敌机发出来的 shot[i].flag=2;//设置标记，让这个弹幕不再持续了 break; &#125; &#125; &#125; &#125;&#125;//碰撞检测，主函数void out_main()&#123; int i,s; for(i=0;i&lt;CSHOT_MAX;i++)&#123;//自机的子弹总数 if(cshot[i].flag&gt;0)&#123; for(s=0;s&lt;ENEMY_MAX;s++)&#123;//敌机总数 if(enemy[s].flag&gt;0)&#123; if(out_judge_cshot(i,s))&#123;//自机子弹和敌机碰撞的话 cshot[i].flag=0;//让那个自机的子弹消失 enemy[s].hp-=cshot[i].power;//根据子弹的威力，减去对应的敌机HP enemy_death_judge(s);//判断敌机是否死亡 &#125; &#125; &#125; &#125; &#125;&#125; ——————————————————————————————————————————————————————————————————————————在out_main 函数里，对所有的自机子弹，和所有的敌机判断是否发生碰撞。相应的，还要做以下的改动。—————————————————————————————————————————————————————————————————————————— 1234567891011121314151617181920212223242526272829303132333435363738394041424344---- main.cpp 做如下改动 ---- case 100://通常处理 calc_ch(); //自机的处理 ch_move(); //自机的移动操作 cshot_main();//自机的射击主函数 enemy_main();//敌机的处理的主函数 shot_main(); //射击的主函数 out_main(); //碰撞检测 graph_main();//绘画的主函数 stage_count++; break;---- function.h 里做如下改动 ----//out.cpp GLOBAL void out_main();---- load.cpp 的 load函数加上下面这些 ---- sound_se[1]=LoadSoundMem(\"dat/se/enemy_death.wav\"); sound_se[2]=LoadSoundMem(\"dat/se/cshot.wav\"); sound_se[8]=LoadSoundMem(\"dat/se/hit.wav\"); ChangeVolumeSoundMem( 50, sound_se[0] ) ;//设定各个素材的回放音量 ChangeVolumeSoundMem(128, sound_se[1] ) ; ChangeVolumeSoundMem(128, sound_se[2] ) ; ChangeVolumeSoundMem( 80, sound_se[8] ) ;---- music.cpp 的 music_play改成如下这样 ----void music_play()&#123; int i; for(i=0;i&lt;SE_MAX;i++)&#123; if(se_flag[i]==1)&#123; if(CheckSoundMem(sound_se[i])!=0)&#123; if(i==8)continue; StopSoundMem(sound_se[i]); &#125; PlaySoundMem(sound_se[i],DX_PLAYTYPE_BACK); &#125; &#125;&#125; ——————————————————————————————————————————————————————————————————————————最后加上去的 music_play 函数的if(i==8)continue;这么写是不是有什么原因呢，敌人被击中时发出的8号音效，如果他已经在播放的话，就停止让他从头播放，就能听到扑扑扑的声音。也就是说，一定要让他放完之后，重头再开始播放。这次，因为只有8号音效需要这样，所以我们就先改成这样。Excel 文件作适当的变更。 执行结果 http://dixq.net/rp/swf/18.swf 原文地址：http://dixq.net/rp/18.html 这次的内容是碰撞检测相关的方面。做过STG的人的话，可能会说“用勾股定理就轻松搞定了啦”这样的观点。但当子弹的射速比较快的时候，只用那个就可能不行了。如果对和碰撞检测相关的用勾股定理判定的方法不太清楚的话，到游戏编程馆里的第s11章去看一下先吧。 看这里假设碰撞检测的有效范围是10，子弹的速度是100的话，会怎么样呢？子弹每次会移动100的距离，但碰撞检测只能对那10 的范围进行检测，也就是说，子弹在高速移动的话，会有检测不到的地方。因此，有可能发生敌人直接穿过自机的子弹的情况。为了避免这样的情况，要对自机子弹通过的地方，一点一点的进行检查，必须要保证没有遗漏的地方。那么，啰嗦了这么多，我们就按如下步骤进行实现吧。在out_judge_cshot 函数里，把传进来的 i 号的自机子弹， 和 s 号的敌机进行碰撞检测，＞if(cshot[i].cnt&gt;0){也就是说，一旦计算了子弹的轨道，要回到一帧以前的位置开始，一点一点的让子弹飞向现在的位置，同时判断子弹和敌机是否发生碰撞，这样对每一部都进行检测才行。实现过程如下。（睡觉先，2:39了）———————————————————————————————————————————————————————————————————————— 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879---- out.cpp を変更 ----#include \"../include/GV.h\"#define ENEMY_RANGE_MAX 4#define CSHOT_RANGE_MAX 2//敌机的碰撞检测范围int enemy_range[ENEMY_RANGE_MAX]=&#123;16,30,16,50&#125;;//自机的子弹的碰撞检测范围int cshot_range[CSHOT_RANGE_MAX]=&#123;6,&#125;;//判断是否发生碰撞int out_judge_cshot(int i,int s)&#123; int j; if(cshot[i].cnt&gt;0)&#123;//每一帧都对子弹的轨道进行计算 double x=cshot[i].x-enemy[s].x;//敌机和自机子弹的距离 double y=cshot[i].y-enemy[s].y; //超界的判断 if(cshot[i].knd&gt;=CSHOT_RANGE_MAX || enemy[s].knd&gt;=ENEMY_RANGE_MAX) printfDx(\"out_judge_cshot内オーバーフロー\"); //敌机的判定和自己子弹判定的加起来的范围 double r=cshot_range[cshot[i].knd]+enemy_range[enemy[s].knd]; //如果需要中间计算 if(cshot[i].spd&gt;r)&#123; //保存下前一帧所在的位置 double pre_x=cshot[i].x+cos(cshot[i].angle+PI)*cshot[i].spd; double pre_y=cshot[i].y+sin(cshot[i].angle+PI)*cshot[i].spd; double px,py; for(j=0;j&lt;cshot[i].spd/r;j++)&#123;//前进的部分除以碰撞判定的部分，循环这么多次 px=pre_x-enemy[s].x; py=pre_y-enemy[s].y; if(px*px+py*py&lt;r*r) return 1; pre_x+=cos(cshot[i].angle)*r; pre_y+=sin(cshot[i].angle)*r; &#125; &#125; if(x*x+y*y&lt;r*r)//检测在碰撞内的话 return 1;//碰撞 &#125; return 0;&#125;//判断敌机是否死亡void enemy_death_judge(int s)&#123; int i; se_flag[8]=1;//敌机被打中的音效 if(enemy[s].hp&lt;0)&#123;//敌机的血量小于0的话 enemy[s].flag=0;//让敌机消失 se_flag[1]=1;//敌机的 BIU 的音效 for(i=0;i&lt;SHOT_MAX;i++)&#123;//遍历所有的弹幕 if(shot[i].flag!=0)&#123;//如果有注册了的弹幕数据 if(s==shot[i].num)&#123;//如果这个弹幕是这个敌机发出来的 shot[i].flag=2;//设置标记，让这个弹幕不再持续了 break; &#125; &#125; &#125; &#125;&#125;//碰撞检测，主函数void out_main()&#123; int i,s; for(i=0;i&lt;CSHOT_MAX;i++)&#123;//自机的子弹总数 if(cshot[i].flag&gt;0)&#123; for(s=0;s&lt;ENEMY_MAX;s++)&#123;//敌机总数 if(enemy[s].flag&gt;0)&#123; if(out_judge_cshot(i,s))&#123;//自机子弹和敌机碰撞的话 cshot[i].flag=0;//让那个自机的子弹消失 enemy[s].hp-=cshot[i].power;//根据子弹的威力，减去对应的敌机HP enemy_death_judge(s);//判断敌机是否死亡 &#125; &#125; &#125; &#125; &#125;&#125; ——————————————————————————————————————————————————————————————————————————在out_main 函数里，对所有的自机子弹，和所有的敌机判断是否发生碰撞。相应的，还要做以下的改动。—————————————————————————————————————————————————————————————————————————— 1234567891011121314151617181920212223242526272829303132333435363738394041424344---- main.cpp 做如下改动 ---- case 100://通常处理 calc_ch(); //自机的处理 ch_move(); //自机的移动操作 cshot_main();//自机的射击主函数 enemy_main();//敌机的处理的主函数 shot_main(); //射击的主函数 out_main(); //碰撞检测 graph_main();//绘画的主函数 stage_count++; break;---- function.h 里做如下改动 ----//out.cpp GLOBAL void out_main();---- load.cpp 的 load函数加上下面这些 ---- sound_se[1]=LoadSoundMem(\"dat/se/enemy_death.wav\"); sound_se[2]=LoadSoundMem(\"dat/se/cshot.wav\"); sound_se[8]=LoadSoundMem(\"dat/se/hit.wav\"); ChangeVolumeSoundMem( 50, sound_se[0] ) ;//设定各个素材的回放音量 ChangeVolumeSoundMem(128, sound_se[1] ) ; ChangeVolumeSoundMem(128, sound_se[2] ) ; ChangeVolumeSoundMem( 80, sound_se[8] ) ;---- music.cpp 的 music_play改成如下这样 ----void music_play()&#123; int i; for(i=0;i&lt;SE_MAX;i++)&#123; if(se_flag[i]==1)&#123; if(CheckSoundMem(sound_se[i])!=0)&#123; if(i==8)continue; StopSoundMem(sound_se[i]); &#125; PlaySoundMem(sound_se[i],DX_PLAYTYPE_BACK); &#125; &#125;&#125; ——————————————————————————————————————————————————————————————————————————最后加上去的 music_play 函数的if(i==8)continue;这么写是不是有什么原因呢，敌人被击中时发出的8号音效，如果他已经在播放的话，就停止让他从头播放，就能听到扑扑扑的声音。也就是说，一定要让他放完之后，重头再开始播放。这次，因为只有8号音效需要这样，所以我们就先改成这样。Excel 文件作适当的变更。 执行结果 http://dixq.net/rp/swf/18.swf 擦，你妹的CSDN，要我输验证码，我输半天，半个字都没错，就是不让我过。就让我输一些很2 的算式，你这验证码系统有问题是吧！！！ 打了一局游戏，本来想发到其他坛子，对CSDN太失望了。回来一想，这是要我输个数字？然后输入了个数字，竟然行了。。。 你妹的这验证码 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"http://yoursite.com/tags/碰撞检测/"}]},{"title":"【四圣龙神录的编程教室】第17章、让自机可以发射子弹吧","date":"2014-03-12T17:04:00.000Z","path":"2014/03/13/【四圣龙神录的编程教室】第17章、让自机可以发射子弹吧/","text":"原文地址：http://dixq.net/rp/17.html 那么，看起来已经有点像样了呢。把自机的射击功能和碰撞检测加上的话，大部分的架构就完成了。自机的射击实现方式也是和基本的敌机射击的实现是差不多的。制作一个保存子弹信息的结构，把种类，速度，角度等等保存进去就行了。这些数值设置好了之后，计算部分就可以轻松的算出轨道和碰撞信息了。那么，我们先和往常一样，准备好变量和结构体。 —————————————————————————————————————————————————————————————— 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091---- struct.h 里加入下面红色部分----//自机的子弹相关的构造体（红色的）typedef struct&#123; int flag,power,cnt,knd;//标志，火力，计数，种类 double x,y,angle,spd;//坐标，角度，速度&#125;cshot_t;//自机相关的构造体typedef struct&#123; int flag; //フラグ int cnt; //カウンタ int power; //パワー int point; //ポイント int score; //スコア int num; //残機数 int mutekicnt; //無敵状態とカウント int shot_mode; //ショットモード int money; //お金 int img; int slow; //スローかどうか double x,y; //座標 int shot_cnt; //射击的计数（红色）&#125;ch_t;---- define.h 里加入下面语句 ----//自机发射子弹的最大数目#define CSHOT_MAX 200---- GV.h 里加入下面语句 ----GLOBAL int img_cshot[2]; //自机子弹所用的图像GLOBAL cshot_t cshot[CSHOT_MAX];//自机子弹注册用的变量---- load.cpp 的 load()函数里添加下面语句 ----img_cshot[0]=LoadGraph(\"../dat/img/char/bl_00.png\");img_cshot[1]=LoadGraph(\"../dat/img/char/bl_01.png\");sound_se[2]=LoadSoundMem(\"../dat/se/cshot.wav\");---- ini.cpp 的 ini函数里添加下面语句 ----memset(cshot,0,sizeof(cshot_t)*CSHOT_MAX);ch.power=500;---- function.h 里添加下面的语句 ----GLOBAL void cshot_main();---- graph.cpp 里添加下面的语句 ----void graph_cshot()&#123; for(int i=0;i&lt;CSHOT_MAX;i++)&#123; if(cshot[i].flag&gt;0)&#123; DrawRotaGraphF(cshot[i].x+FIELD_X,cshot[i].y+FIELD_Y,1,0, img_cshot[cshot[i].knd],TRUE); &#125; &#125;&#125;---- graph.cpp 的 graph_main函数改为 ----void graph_main()&#123; graph_enemy(); graph_cshot(); graph_ch(); graph_bullet(); graph_board();&#125;---- main.cpp 的main函数的switch部分改成下面这样 ---- case 100://通常的处理 calc_ch(); //自机的处理 ch_move(); //自机的移动处理 cshot_main();//自机射击的主函数 enemy_main();//敌机处理的主函数 shot_main();//射击的主函数 graph_main();//绘制的主函数 stage_count++; break; ——————————————————————————————————————————————————————————————最后，自机子弹的登陆是必不可少的。当自机的火力是200以下的话就是两发，以上的话就是4发子弹。4发子弹的位置，就像下面看起来这样。————————————————————————————————————————————————————————————int cshot0pos_x[4]={-10, 10,-30, 30};int cshot0pos_y[4]={-30,-30,-10,-10};————————————————————————————————————————————————————————————第一发在(-10,-30) 的位置，第二发在(10,-30)的位置，第三发在(-30,-10)的位置……就像这样。这次和之前的一样，准备了子弹登陆的保存的位置，子弹登陆的时候在int search_cshot()方法里，找一个空的位置，来存放登陆的子弹。———————————————————————————————————————————————————————————————————— 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990---- cshot.cpp 改动 ----#include \"../include/GV.h\"int cshot0num[2] =&#123;2,4&#125;;int cshot0pos_x[4]=&#123;-10, 10,-30, 30&#125;;int cshot0pos_y[4]=&#123;-30,-30,-10,-10&#125;;//返回自机子弹可以存放的位置编号int search_cshot()&#123; for(int i=0;i&lt;CSHOT_MAX;i++)&#123; if(cshot[i].flag==0) return i; &#125; return -1;&#125;//普通子弹登陆void ch0_shot_pattern()&#123; int k; for(int i=0;i&lt;cshot0num[ch.power&lt;200?0:1];i++)&#123; if((k=search_cshot())!=-1)&#123; cshot[k].flag=1; cshot[k].cnt=0; cshot[k].angle=-PI/2; cshot[k].spd=20; cshot[k].x=ch.x+cshot0pos_x[i]; cshot[k].y=ch.y+cshot0pos_y[i]; cshot[k].power=23; cshot[k].knd=0; &#125; &#125; se_flag[2]=1;//发射音效&#125;//低速子弹登陆void ch1_shot_pattern()&#123; int k; for(int i=0;i&lt;cshot0num[ch.power&lt;200?0:1];i++)&#123; if((k=search_cshot())!=-1)&#123; cshot[k].flag=1; cshot[k].cnt=0; cshot[k].angle=-PI/2; cshot[k].spd=20; cshot[k].x=ch.x+cshot0pos_x[i]/3;//低速的话，位置往中间靠 cshot[k].y=ch.y+cshot0pos_y[i]/2; cshot[k].power=23; cshot[k].knd=0; &#125; &#125; se_flag[2]=1;&#125;//子弹登陆部分void enter_shot()&#123; //子弹发射按键按下的话 if(CheckStatePad(configpad.shot)&gt;0)&#123; ch.shot_cnt++; if(ch.shot_cnt%3==0)&#123;//每3帧内一次 if(CheckStatePad(configpad.slow)&gt;0)//如果是低速的话 ch1_shot_pattern(); else ch0_shot_pattern(); &#125; &#125; else ch.shot_cnt=0;&#125;//子弹的移动计算void calc_cshot()&#123; for(int i=0;i&lt;CSHOT_MAX;i++)&#123; if(cshot[i].flag==1)&#123; int dranx=cshot[i].spd+11/2,drany=cshot[i].spd+55/2; cshot[i].x+=cos(cshot[i].angle)*cshot[i].spd; cshot[i].y+=sin(cshot[i].angle)*cshot[i].spd; cshot[i].cnt++; if(cshot[i].x&lt;-dranx || cshot[i].x&gt;FIELD_MAX_X+dranx || cshot[i].y&lt;-drany || cshot[i].y&gt;FIELD_MAX_Y+drany)//已经在画面外的话 cshot[i].flag=0; &#125; &#125;&#125;//自机子弹相关的函数void cshot_main()&#123; calc_cshot();//子弹的轨道计算 enter_shot();//子弹登陆&#125; ——————————————————————————————————————————————————————————————————————————calc_cshot() 会对子弹在画面外做判定，为什么用int dranx=cshot[i].spd+11/2,drany=cshot[i].spd+55/2;这样来判定，这里补充说明一下。下一章会讲碰撞检测，预先对那个做一些了解是有必要的，下一章不会讲这段代码了，所以我们先在这里讲了吧。子弹只靠勾股定理来检测是否碰撞是不够的。比如说，子弹的速度是200，子弹的判定大小是10，那么有190的范围是不会碰到的。也就是说，必须要根据子弹的轨迹来计算是否会产生碰撞。当子弹在画面外的时候，子弹就被消除了，最后的轨迹就计算不出来了。也就是说，当上一帧子弹在画面外，这一帧子弹还是在画面外的话，才可以被消除。此外，11 和 55 这两个数，是子弹大小的尺寸。。。如果， 子弹的坐标在，相对画面移动的速度+ 子弹图像尺寸的一半，这里的话，我们知道他上一帧也在画面外，所以，这个子弹就可以消除了。这样的处理，就是为了处理那样的情况，所以才这么写。运行结果： http://dixq.net/rp/swf/17.swf 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第16章、来制作洩矢大人的弹幕吧","date":"2014-03-09T07:32:00.000Z","path":"2014/03/09/【四圣龙神录的编程教室】第16章、来制作矢大人的弹幕吧/","text":"原文地址：http://dixq.net/rp/16.html 因为之前已经做好了固定的模式，所以弹幕的添加就变的很容易了。这次只要把弹幕函数进行改动就行了。我们就用shot_bullet_H008来实现洩矢大人的弹幕吧。【洩矢大人】这个弹幕是东方风神录EX面的最后一个弹幕。 不太清楚的人看下面的视频来确认一下吧。（对不起，原文给nico的地址我打不开，只好发b站的了）http://www.bilibili.tv/search?keyword=%E9%A3%8E%E7%A5%9E%E5%BD%95+ex&amp;orderby=&amp;formsubmit=很意外的是，EX面的最后一个弹幕是这么简单的实现的，这么说的话东方厨们也许会不高兴，但我们还是来简单的实现一个相似的弹幕来吧。 ———————————————————————————————————————————————————————————————————————— 12345678910111213141516171819202122232425262728293031323334353637---- shotH.cpp里添加如下代码 ----//崇符【洩矢大人】void shot_bullet_H008(int n)&#123; int t=shot[n].cnt; int k; if(t&gt;=0 &amp;&amp; t&lt;1200 &amp;&amp; t%90==0)&#123; double angle=rang(PI); for(int j=0;j&lt;2;j++)&#123;//在中途分裂成两部分 for(int i=0;i&lt;60;i++)&#123;//每部分60个 if(shot[n].flag!=2 &amp;&amp; (k=shot_search(n))!=-1)&#123; shot[n].bullet[k].knd =8;//第八号子弹 shot[n].bullet[k].angle =angle+PI2/60*i;//圆形 60个 shot[n].bullet[k].flag =1; shot[n].bullet[k].x =enemy[shot[n].num].x; shot[n].bullet[k].y =enemy[shot[n].num].y; shot[n].bullet[k].col =4;//四号颜色 shot[n].bullet[k].cnt =0; shot[n].bullet[k].state =j;//状态。根据是0还是1来区分旋转方向 shot[n].bullet[k].spd =2; &#125; &#125; &#125; se_flag[0]=1;//发射音效 &#125; for(int i=0;i&lt;SHOT_BULLET_MAX;i++)&#123;//所有子弹 if(shot[n].bullet[i].flag&gt;0)&#123;//有注册了的子弹的话 int state=shot[n].bullet[i].state; int cnt=shot[n].bullet[i].cnt; if(30&lt;cnt &amp;&amp; cnt&lt;120)&#123;//在 30 -120 的时间内 shot[n].bullet[i].spd-=1.2/90.0;//速度减少 1.2/90 shot[n].bullet[i].angle+=(PI/2)/90.0*(state?-1:1);//倾斜90度/90 &#125; &#125; &#125;&#125; ————————————————————————————————————————————————————————————————————————子弹的编号在 bullet 文件夹里可以找到和子弹编号一样的图片，来确认下。（b8.png）最左边的是0号的话，颜色编号为1号的就是水珠的颜色，颜色就指定为1号吧。这里要传0或者1给state参数，洩矢大人的弹幕在一个地方会发射2个子弹，中途会变成2个轨道。在那里，你会看到，状态为0的弹幕会往角度的正方向变化，状态为1的弹幕相反。shot[n].bullet[i].angle+=(PI/2)/90.0*(state?-1:1);代入这里。问号是条件运算符，不知道的去谷歌一下吧。这样做的话，两种角度的弹幕就出来了。 /カウンタ移動パターン敵の種類x座標y座標スピード発射時間弾幕種類弾の色体力弾種類待機時間アイテム123456/cntpatternkndxyspbltimeblkndcolhpblknd2waititem_n 609020015006081100012000-1-1-1-1-1运行结果http://dixq.net/rp/swf/16.swf 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第15章、来制作凹梦的弹幕吧","date":"2014-03-06T19:11:00.000Z","path":"2014/03/07/【四圣龙神录的编程教室】第15章、来制作凹梦的弹幕吧/","text":"原文地址：http://dixq.net/rp/15.html 咦，标题有点奇怪？别在意这些细节。那么，基本的弹幕制作方法都已经明白了，我们试着做一些稍微复杂点的弹幕吧。虽然这么说，但一下子就弄很难的弹幕会很难理解，还是从简单点的开始吧。这回，首先看一下最终的执行效果。运行结果：http://dixq.net/rp/swf/15.swf 严格的来说，这个和妖梦的弹幕稍微有点不一样。如果要弄的完全一样的话计算方式会变得很复杂，我们就简化一下吧。要怎么样才能发射出这样的弹幕呢？发射地点是绕着敌人为中心的圆形旋转移动的，是吧？是从下往上的半圈呢。这是从敌人开始的位置当做 PI/2 的位置的话，从 PI/2 + PI 和 PI/2 -PI的方向旋转的，是吧？这次，在150帧里面发射15次弹幕来看看效果吧。 —————————————————————————————————————————————————————————————————— 1234567891011121314151617181920212223242526272829303132333435//---- shotH.cpp添加如下代码 ----//凹梦的弹幕void shot_bullet_H007(int n)&#123; int t=shot[n].cnt; int k; if(t&gt;=0 &amp;&amp; t&lt;=150 &amp;&amp; t%10==0)&#123; for(int i=0;i&lt;20;i++)&#123; if(shot[n].flag!=2 &amp;&amp; (k=shot_search(n))!=-1)&#123; shot[n].bullet[k].knd =7; shot[n].bullet[k].angle =PI2/20*i; shot[n].bullet[k].flag =1; shot[n].bullet[k].x =enemy[shot[n].num].x+cos(PI/2+PI/150*t)*100; shot[n].bullet[k].y =enemy[shot[n].num].y+sin(PI/2+PI/150*t)*100; shot[n].bullet[k].col =2; shot[n].bullet[k].cnt =0; shot[n].bullet[k].spd =1.2; &#125; &#125; for(int i=0;i&lt;20;i++)&#123; if(shot[n].flag!=2 &amp;&amp; (k=shot_search(n))!=-1)&#123; shot[n].bullet[k].knd =7; shot[n].bullet[k].angle =PI2/20*i; shot[n].bullet[k].flag =1; shot[n].bullet[k].x =enemy[shot[n].num].x+cos(PI/2-PI/150*t)*100; shot[n].bullet[k].y =enemy[shot[n].num].y+sin(PI/2-PI/150*t)*100; shot[n].bullet[k].col =4; shot[n].bullet[k].cnt =0; shot[n].bullet[k].spd =1.2; se_flag[0]=1; &#125; &#125; &#125;&#125; ——————————————————————————————————————————————————————————————————cos(PI/2+PI/150t)100;在这个表达式里，cos 是算出把x 方向的分量，转化为 0 到1 之间，然后乘以圆的半径100。如果要调整圆的大小的话，修改这个100 就行了。然后，后面每一章都要修改声明定义弹幕的函数的话很麻烦，我们预先声明18个弹幕模式好了。—————————————————————————————————————————————————————————————— 12345678910111213141516171819202122232425262728293031323334//---- shotH.cpp里添加如下代码 ----void shot_bullet_H008(int n)&#123;&#125;void shot_bullet_H009(int n)&#123;&#125;void shot_bullet_H010(int n)&#123;&#125;void shot_bullet_H011(int n)&#123;&#125;void shot_bullet_H012(int n)&#123;&#125;void shot_bullet_H013(int n)&#123;&#125;void shot_bullet_H014(int n)&#123;&#125;void shot_bullet_H015(int n)&#123;&#125;void shot_bullet_H016(int n)&#123;&#125;void shot_bullet_H017(int n)&#123;&#125;//---- shot.cpp 里随便找个地方添加如下代码 ----extern void shot_bullet_H000(int);extern void shot_bullet_H001(int);extern void shot_bullet_H002(int);extern void shot_bullet_H003(int);extern void shot_bullet_H004(int);extern void shot_bullet_H005(int);extern void shot_bullet_H006(int);extern void shot_bullet_H007(int);extern void shot_bullet_H008(int);extern void shot_bullet_H009(int);extern void shot_bullet_H010(int);extern void shot_bullet_H011(int);extern void shot_bullet_H012(int);extern void shot_bullet_H013(int);extern void shot_bullet_H014(int);extern void shot_bullet_H015(int);extern void shot_bullet_H016(int);extern void shot_bullet_H017(int);void (*shot_bullet[SHOT_KND_MAX])(int) =&#123; shot_bullet_H000,shot_bullet_H001,shot_bullet_H002,shot_bullet_H003,shot_bullet_H004, shot_bullet_H005,shot_bullet_H006,shot_bullet_H007,shot_bullet_H008,shot_bullet_H009, shot_bullet_H010,shot_bullet_H011,shot_bullet_H012,shot_bullet_H013,shot_bullet_H014, shot_bullet_H015,shot_bullet_H016,shot_bullet_H017,&#125;;//---- define.h 的定义改成这样 ----#define SHOT_KND_MAX 18 ——————————————————————————————————————————————————————————————下面是Excel 文档的改动。以后弹幕的编号改动了的话，只需要改【弹幕种类】，一点一点增加就行了。 /帧数移动模式敌人种类x坐标y坐标速度发射时间弹幕种类弹幕颜色体力子弹种类待机时间道具123456/cntpatternkndxyspbltimeblkndcolhpblknd2waititem_n 60902001500607010002000-1-1-1-1-1 Excel文档下载（PS： 2014年3月7日笔记：昨晚写完后，本来想给弹幕写个人的注释，发现到后面还是没理解，于是作罢。睡觉前终于想清楚了.enemy[shot[n].num].x+cos(PI/2-PI/150*t)*100;enemy[shot[n].num].y+sin(PI/2-PI/150*t)*100;这两句，是根据 t 的变化，让发射的起始点顺着以敌机为圆心，100为半径的圆周移动的。当 t =0 的时候，很容易分析出，x 不变，y +100 。 可是实际调试的时候发现，t 改为0，发射点就在敌机下方。y 不是加100么，怎么在下方的呢？然后突然想到了，恍然大悟，在这里窗口的y 轴是向下的，这也就很好的解释了里面说的 从 PI/2 到 PI/2 +PI 和 从PI/2 到 PI/2-PI 这两个方向了。PI/2 就是向下的方向，因为y轴向下，x轴向右，这里算角度是从x轴往下，顺时针计算的。其他就没什么了，每次发射的，不过是20颗等分圆的圆形弹幕而已） 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"github 新手使用记录","date":"2014-02-19T16:58:00.000Z","path":"2014/02/20/github 新手使用记录/","text":"个人用github 的笔记。网上各种各样的github 教程都有，但可能很多人像我这样，照着看，似懂非懂的操作成功了，以后要用到什么功能又去查，反正，还是不懂。现在新建了一个项目 传到 github，记录下用的命令些。 基本参考 http://serholiu.com/github-share-code这个写的很简洁，也很明了。 其中有个地方， 在 git add all . 之前，可以在项目里 新建一个 .gitignore 文件。 就为了加上这个，我又把项目删了重建，整了好几次。bash 里输入 touch .gitignore 新建这个文件，然后把项目不需要的添加进去，可以网上搜。 然后 git add all . 就可以commit了。 然后到家了，找到 workspace 文件夹，bash 定位到这里，输入 git clone git@github.com/git 这样，就行了 git 上 add 了多余的文件，要删掉，不是输 git rm 。 我就是因为这，把文件全删掉了，要从stage 中移除，是 git rm –cached readme.txt 只从stage中删除，保留物理文件。http://www.cnblogs.com/lwzz/archive/2013/02/23/2921426.html 然后，push remote 的时候可能会失败，提示个no access to reposity 什么的。可能是地址搞错了，这个存在 .git/config 文件中，把里面的remote 这段删了，重新添加即可。 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"【四圣龙神录的编程教室】第14章、来制作各种各样的弹幕数据吧","date":"2014-02-17T16:18:00.000Z","path":"2014/02/18/【四圣龙神录的编程教室】第14章、来制作各种各样的弹幕数据吧/","text":"原文地址：http://dixq.net/rp/14.html 那些麻烦的设定终于搞定了，那么这次我们就来做各种各样的弹幕数据吧。下面是一直发射自机狙的弹幕函数001.往 shotatan2 函数里，传入n，就可以返回自机和编号为n的敌机的角度，这样很简单就把射向自机的角度传给angle 变量了。 —————————————————————————————————————————————————————————————————— 123456789101112131415161718//100个里面有10发子弹、向自机的方向直线发射(始终瞄准自机)void shot_bullet_H001(int n)&#123; int t=shot[n].cnt; int k; if(t&gt;=0 &amp;&amp; t&lt;100 &amp;&amp; t%10==0)&#123;//100次里面，每10次出现1次 if(shot[n].flag!=2 &amp;&amp; (k=shot_search(n))!=-1)&#123;//敌人存在、并且子弹可以登录 shot[n].bullet[k].knd =enemy[shot[n].num].blknd2;//子弹登录 shot[n].bullet[k].angle =shotatan2(n);//角度 shot[n].bullet[k].flag =1;//标志 shot[n].bullet[k].x =enemy[shot[n].num].x;//坐标 shot[n].bullet[k].y =enemy[shot[n].num].y; shot[n].bullet[k].col =enemy[shot[n].num].col;//颜色 shot[n].bullet[k].cnt =0;//计数 shot[n].bullet[k].spd =3;//速度 se_flag[0]=1; &#125; &#125;&#125; ——————————————————————————————————————————————————————————————————只是看各个变量的数值可能不是很明白，我们拿运行的结果来比较一下看看吧。—————————————————————————————————————————————————————————————————— 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145---- shotH.cpp的改动 ----#include \"../include/GV.h\"//只有一发子弹、向自机方向直线发射void shot_bullet_H000(int n)&#123; int k; if(shot[n].cnt==0)&#123; if(shot[n].flag!=2 &amp;&amp; (k=shot_search(n))!=-1)&#123; shot[n].bullet[k].knd =enemy[shot[n].num].blknd2; shot[n].bullet[k].angle =shotatan2(n); shot[n].bullet[k].flag =1; shot[n].bullet[k].x =enemy[shot[n].num].x; shot[n].bullet[k].y =enemy[shot[n].num].y; shot[n].bullet[k].col =enemy[shot[n].num].col; shot[n].bullet[k].cnt =0; shot[n].bullet[k].spd =3; se_flag[0]=1; &#125; &#125;&#125;//100发中有10发、往自机方向直线发射(始终瞄准自机)void shot_bullet_H001(int n)&#123; int t=shot[n].cnt; int k; if(t&gt;=0 &amp;&amp; t&lt;100 &amp;&amp; t%10==0)&#123;//在100发里，每10发出现一次 if(shot[n].flag!=2 &amp;&amp; (k=shot_search(n))!=-1)&#123;//敌机存在，并且子弹可以注册的话 shot[n].bullet[k].knd =enemy[shot[n].num].blknd2;//子弹注册 shot[n].bullet[k].angle =shotatan2(n);//角度 shot[n].bullet[k].flag =1;//标志 shot[n].bullet[k].x =enemy[shot[n].num].x;//坐标 shot[n].bullet[k].y =enemy[shot[n].num].y; shot[n].bullet[k].col =enemy[shot[n].num].col;//颜色 shot[n].bullet[k].cnt =0;//计数 shot[n].bullet[k].spd =3;//速度 se_flag[0]=1; &#125; &#125;&#125;//100发中有10发、往自机方向直线发射(角度记忆)void shot_bullet_H002(int n)&#123; int t=shot[n].cnt; int k; if(t&gt;=0 &amp;&amp; t&lt;100 &amp;&amp; t%10==0)&#123; if(t==0) shot[n].base_angle[0]=shotatan2(n); if(shot[n].flag!=2 &amp;&amp; (k=shot_search(n))!=-1)&#123; shot[n].bullet[k].knd =enemy[shot[n].num].blknd2; shot[n].bullet[k].angle =shot[n].base_angle[0]; shot[n].bullet[k].flag =1; shot[n].bullet[k].x =enemy[shot[n].num].x; shot[n].bullet[k].y =enemy[shot[n].num].y; shot[n].bullet[k].col =enemy[shot[n].num].col; shot[n].bullet[k].cnt =0; shot[n].bullet[k].spd =3; se_flag[0]=1; &#125; &#125;&#125;//100发中有10发、往自机方向变速地直线发射void shot_bullet_H003(int n)&#123; int t=shot[n].cnt; int k; if(t&gt;=0 &amp;&amp; t&lt;100 &amp;&amp; t%10==0)&#123; if(shot[n].flag!=2 &amp;&amp; (k=shot_search(n))!=-1)&#123; shot[n].bullet[k].knd =enemy[shot[n].num].blknd2; shot[n].bullet[k].angle =shotatan2(n); shot[n].bullet[k].flag =1; shot[n].bullet[k].x =enemy[shot[n].num].x; shot[n].bullet[k].y =enemy[shot[n].num].y; shot[n].bullet[k].col =enemy[shot[n].num].col; shot[n].bullet[k].cnt =0; shot[n].bullet[k].spd =1+5.0/100*t; se_flag[0]=1; &#125; &#125;&#125;//每0.5秒一次的圆形发射void shot_bullet_H004(int n)&#123; int t=shot[n].cnt; int k; if(t&gt;=0 &amp;&amp; t&lt;120 &amp;&amp; t%20==0)&#123; double angle=shotatan2(n); for(int i=0;i&lt;20;i++)&#123; if(shot[n].flag!=2 &amp;&amp; (k=shot_search(n))!=-1)&#123; shot[n].bullet[k].knd =enemy[shot[n].num].blknd2; shot[n].bullet[k].angle =angle+PI2/20*i; shot[n].bullet[k].flag =1; shot[n].bullet[k].x =enemy[shot[n].num].x; shot[n].bullet[k].y =enemy[shot[n].num].y; shot[n].bullet[k].col =enemy[shot[n].num].col; shot[n].bullet[k].cnt =0; shot[n].bullet[k].spd =4; &#125; se_flag[0]=1; &#125; &#125;&#125;//散射void shot_bullet_H005(int n)&#123; int t=shot[n].cnt; int k; if(t&gt;=0 &amp;&amp; t&lt;120 &amp;&amp; t%2==0)&#123; if(shot[n].flag!=2 &amp;&amp; (k=shot_search(n))!=-1)&#123; shot[n].bullet[k].knd =enemy[shot[n].num].blknd2; shot[n].bullet[k].angle =shotatan2(n)+rang(PI/4); shot[n].bullet[k].flag =1; shot[n].bullet[k].x =enemy[shot[n].num].x; shot[n].bullet[k].y =enemy[shot[n].num].y; shot[n].bullet[k].col =enemy[shot[n].num].col; shot[n].bullet[k].cnt =0; shot[n].bullet[k].spd =3+rang(1.5); se_flag[0]=1; &#125; &#125;&#125;//散射(减速)void shot_bullet_H006(int n)&#123; int t=shot[n].cnt; int k; if(t&gt;=0 &amp;&amp; t&lt;120 &amp;&amp; t%2==0)&#123; if(shot[n].flag!=2 &amp;&amp; (k=shot_search(n))!=-1)&#123; shot[n].bullet[k].knd =enemy[shot[n].num].blknd2; shot[n].bullet[k].angle =shotatan2(n)+rang(PI/4); shot[n].bullet[k].flag =1; shot[n].bullet[k].x =enemy[shot[n].num].x; shot[n].bullet[k].y =enemy[shot[n].num].y; shot[n].bullet[k].col =enemy[shot[n].num].col; shot[n].bullet[k].cnt =0; shot[n].bullet[k].spd =4+rang(2); se_flag[0]=1; &#125; &#125; for(int i=0;i&lt;SHOT_BULLET_MAX;i++)&#123;//所有子弹进行循环 if(shot[n].bullet[i].spd&gt;1.5)//子弹的速度比1.5还要大的话 shot[n].bullet[i].spd-=0.04;//减速 &#125;&#125; ——————————————————————————————————————————————————————————————————添加上面这些弹幕的同时，下面这里也做一下改动 /カウンタ移動パターン敵の種類x座標y座標スピード発射時間弾幕種類弾の色体力弾種類待機時間アイテム123456/cntpatternkndxyspbltimeblkndcolhpblknd2waititem_n 60902001500600010071200-1-1-1-1-1200901801500601010081200-1-1-1-1-1340902001500602010091200-1-1-1-1-1480901801500603010001200-1-1-1-1-1620902001500604010071200-1-1-1-1-1760901801500605010081200-1-1-1-1-1900901801500606010081200-1-1-1-1-1移动模式9里面，把上面的弹幕种类都包含进去了。我们往【弹幕种类】里，传入06，代表这次制作的06的弹幕数据。 Excel文件下载———————————————————————————————————————————————————————————————————— 123456789101112131415161718192021222324252627282930---- shot.cpp的exntern声明部分和指针代入部分作如下修改 ----extern void shot_bullet_H000(int);extern void shot_bullet_H001(int);extern void shot_bullet_H002(int);extern void shot_bullet_H003(int);extern void shot_bullet_H004(int);extern void shot_bullet_H005(int);extern void shot_bullet_H006(int);void (*shot_bullet[SHOT_KND_MAX])(int) =&#123; shot_bullet_H000, shot_bullet_H001, shot_bullet_H002, shot_bullet_H003, shot_bullet_H004, shot_bullet_H005, shot_bullet_H006,&#125;;---- function.h 里添加下面这行 ----GLOBAL double rang(double);---- define.h 做如下变更 ----#define SHOT_KND_MAX 7 ————————————————————————————————————————————————————————————————————运行结果http://dixq.net/rp/swf/14.swf (又停了好久，我感觉我翻译完估计要几年，然后学着做又要几年。。。 之前玩剑灵，觉得没意思了。又蛋疼玩起dota了，也觉得浪费时间，于是现在又抽时间把这个继续做下去)（2014-3-5 笔记：从这章和上一章的代码对比，可以看到改动很少，主要就3个文件。一个是敌机进入的数据，保存在csv文件中，控制敌机登场的时间，移动模式，发弹时间和类型等等。看了下这次的csv文件，可以看到敌机的移动都使用第9种移动方式，在某个时间出现，过了wait 时间后，就往上移动。这次主要是展示不同的弹幕。0号弹幕和之前一样，在敌机位置生成一颗子弹，角度朝向自机移动。1号弹幕，从0到100的时间刻度内，每过10个时间刻度，发射一枚子弹，朝向自机。（10枚每个发射时都朝自机方向）2号弹幕，也是像上面这样100帧内发射10颗。但只有第一颗会朝自机方向，后面的子弹都按照这个角度发射。（10枚都朝同一个方向，也就是记下了角度的）3号弹幕，10枚都朝向自机，每枚子弹都会比上一枚速度更快。4号弹幕，120帧内每20帧发射一次，每次往四周平均发射20枚子弹，也就是圆圈形状。（for里循环20次，每次角度加2*pi/20）5号弹幕，120帧内每2帧发射一枚子弹，角度随机在朝自机的角度+- pi/4 的范围内，速度在1.54.5的范围之内。（rang(n) 生成正负n之内的随机数）6号弹幕，生成和5号一样，但速度在24的范围内，并且速度会慢慢减为1.5. ） 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第13章、给敌人加上射击功能吧","date":"2013-12-26T15:01:00.000Z","path":"2013/12/26/【四圣龙神录的编程教室】第13章、给敌人加上射击功能吧/","text":"原文地址：http://dixq.net/rp/13.html 现在我们已经建立好了敌人的信息，这次我们给敌人添加射击子弹的功能吧。这次要添加的部分很多，我们一边和项目进行比较，一边看吧。首先，弹幕的出现，是在敌机出现开始计算时间，到了设定好的弹幕发射时间时，进行发射的。在敌机上设定的，开始发射弹幕的时间，是bltime 变量。从敌人出现开始计数的变量是 cnt。到了预定的时间，就注册弹幕数据。 ———————————————————————————————————————————————————————————————————— 12345678910111213141516171819202122232425262728293031323334353637383940//---- enemy.cpp 里添加下面红字的部分 ----void enter_shot(int i)&#123; //这个函数都是红字 int j; for(j=0;j&lt;SHOT_MAX;j++)&#123;//根据flag，寻找空闲的enemy if(shot[j].flag==0)&#123;//如果有未使用的弹幕数据 memset(&amp;shot[j],0,sizeof(shot_t));//初始化和注册 shot[j].flag=1;//设置标志 shot[j].knd=enemy[i].blknd;//子弹的种类 shot[j].num=i;//num表示从哪个敌人发射出来的 shot[j].cnt=0; return ; &#125; &#125;&#125;//敌人的行动操作void enemy_act()&#123; int i; for(i=0;i&lt;ENEMY_MAX;i++)&#123; if(enemy[i].flag==1)&#123;//这个敌机的标志设置为开启的话 if(0&lt;=enemy[i].pattern &amp;&amp; enemy[i].pattern&lt;ENEMY_PATTERN_MAX)&#123; enemy_pattern[enemy[i].pattern](i); enemy[i].x+=cos(enemy[i].ang)*enemy[i].sp; enemy[i].y+=sin(enemy[i].ang)*enemy[i].sp; enemy[i].x+=enemy[i].vx; enemy[i].y+=enemy[i].vy; enemy[i].cnt++; enemy[i].img=enemy[i].muki*3+(enemy[i].cnt%18)/6; //敌人移动到画面的外的话进行消除 if(enemy[i].x&lt;-20 || FIELD_MAX_X+20&lt;enemy[i].x || enemy[i].y&lt;-20 || FIELD_MAX_Y+20&lt;enemy[i].y) enemy[i].flag=0; if(enemy[i].bltime==enemy[i].cnt) // 这个if 也是红字 enter_shot(i); &#125; else printfDx(\"enemy[i].pattern的%d值不正确。\",enemy[i].pattern); &#125; &#125;&#125; ————————————————————————————————————————————————————————————————————在这里，那个弹幕数据是什么样的呢，让我们看看构造体的定义和变量的定义吧。注：define.h 里有一句 #include “struct.h”一定要放在文件的最后面。以后的章节也是如此。 ————————————————————————————————————————————————————————————————————— define.h 加入下面的代码 — //一个敌人能持有的子弹最大数量 #define SHOT_BULLET_MAX 1000 //一次画面里能显示的敌人弹幕的最大数量 #define SHOT_MAX 30 //设计种类的最大数量 #define SHOT_KND_MAX 1 //音效种类的最大数量 #define SE_MAX 100 //敌人的行动模式的最大数量 #define ENEMY_PATTERN_MAX 11 — struct.h里加入下面代码 — //子弹相关的构造体typedef struct{//标志、种类、计数、颜色、状态、至少存在的时间、效果的种类 int flag,knd,cnt,col,state,till,eff;//坐标、角度、速度、基准角度、临时储存的速度 double x,y,angle,spd,base_angle[1],rem_spd[1];}bullet_t; //射击相关的构造体typedef struct{//标志、种类、计数、代表从哪个敌人发射的序号 int flag,knd,cnt,num;//基准角度、基准速度 double base_angle[1],base_spd[1]; bullet_t bullet[SHOT_BULLET_MAX];}shot_t; — GV.h 添加如下代码 — GLOBAL int img_bullet[10][10]; //子弹的图像 //音乐文件的变量GLOBAL int sound_se[SE_MAX]; GLOBAL int se_flag[SE_MAX]; //声音的标志 GLOBAL shot_t shot[SHOT_MAX];//射击的数据 — ini.cpp 的 ini() 里添加如下代码 — memset(shot,0,sizeof(shot_t)*SHOT_MAX);————————————————————————————————————————————————————————————————————bullet_t是和子弹相关的构造体。这个也是包含了很多的变量，没必要全部都记住。只要看到了的话，知道包含这样的变量就行了。子弹首先包含一个flag标志，另外还包含飞行的速度和角度，坐标和状态等必要的一些参数。其中 til 表示子弹至少显示多久不消失的 时间技术。如果只是“飞出画面就消除”的话，有些真正自己想做的弹幕会做不出来。所以，至少 在 til 里设定的时间，是就算子弹到了画面外也不会消失的，这个变量就是代表这个含义。eff 是那个子弹会表示什么样的效果， base_angle 是子弹的角度在运动中变化的时候，以此作为一个基准的角度而保存的变量。shot_t 是管理一种弹幕数据的构造体。每种弹幕数据里面，每个变量，有SHOT_BULLET_MAX （这里是1000）个子弹组成。shot_t是敌机进行攻击的弹幕的数据，所以要准备敌机一次能发射的最大树木的子弹数量。总之，如果准备了30种弹幕的话，最终就是要准备 30XSHOT_BULLET_MAX 个子弹。准备了这么多的数量，bullet_t 里就可以不用保存一些没用的变量了。 另外，弹幕数据，子弹数据是一起注册的，在注册的时候要对数据进行计算。哪里，对弹幕数据的主要操作在 shot.cpp 文件里面。———————————————————————————————————————————————————————————————————————————— 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//--- shot.cpp 里这样写 ---#include \"../include/GV.h\"extern void shot_bullet_H000(int);void (*shot_bullet[SHOT_KND_MAX])(int) =&#123; shot_bullet_H000,&#125;;//返回发射第n个子弹的敌机与自机之间的角度double shotatan2(int n)&#123; return atan2(ch.y-enemy[shot[n].num].y,ch.x-enemy[shot[n].num].x); &#125;//寻找空的子弹存放位置int shot_search(int n)&#123; int i; for(i=0; i&lt;SHOT_BULLET_MAX; i++) &#123; if(shot[n].bullet[i].flag==0) &#123; return i; &#125; &#125; return -1;&#125;void shot_main()&#123; int i; for(i=0; i&lt;SHOT_MAX; i++) //弹幕数据的计算 &#123; //设置了flag标志、并且在设置好的的种类里面(防止溢出) if(shot[i].flag!=0 &amp;&amp; 0&lt;=shot[i].knd &amp;&amp; shot[i].knd&lt;SHOT_KND_MAX) &#123; shot_bullet[shot[i].knd](i);//指向 knd的弹幕计算函数的指针 s hot_calc(i); //计算第i个弹幕 shot[i].cnt++; &#125; &#125;&#125;//--- shotH.cpp 里添加下面的代码 ---//子弹射击轨迹只有一种，朝自机方向的直线运动void shot_bullet_H000(int n)&#123; int k; //--- main.cpp 添加了红色部分 --- if(shot[n].cnt==0) &#123; if(shot[n].flag!=2 &amp;&amp; (k=shot_search(n))!=-1) &#123; shot[n].bullet[k].knd =enemy[shot[n].num].blknd2; shot[n].bullet[k].angle =shotatan2(n); shot[n].bullet[k].flag =1; shot[n].bullet[k].x =enemy[shot[n].num].x; shot[n].bullet[k].y =enemy[shot[n].num].y; shot[n].bullet[k].col =enemy[shot[n].num].col; shot[n].bullet[k].cnt =0; shot[n].bullet[k].spd =3; se_flag[0]=1; &#125; &#125;&#125;int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)&#123; ChangeWindowMode(TRUE);//窗口化 if(DxLib_Init() == -1 || SetDrawScreen( DX_SCREEN_BACK )!=0) return -1;//初始化和设置双缓冲 while(ProcessLoop()==0) //主循环 &#123; music_ini(); switch(func_state) &#123; case 0://刚开始进入的处理 load(); //载入数据 first_ini();//刚开始的初始化 func_state=99; break; case 99://STG射击开始前的初始化 ini(); load_story(); func_state=100; break; case 100://通常处理 calc_ch(); //自机的显示 ch_move(); //自己的移动操作 enemy_main();//敌机处理的主函数 shot_main();//射击的主函数 graph_main();//绘图的主函数 stage_count++; break; default: printfDx(\"不正确的func_state\\n\"); break; &#125; music_play(); if(CheckStateKey(KEY_INPUT_ESCAPE)==1)break;//按下ESC的话，退出主循环 ScreenFlip();//刷新双缓冲 &#125; DxLib_End();//DXLib 的结束处理 return 0;&#125; ——————————————————————————————————————————————————————————————————————————— 一直到弹幕的最大数量为止，对注册进来的东西一直循环，注册进来的数据，都交给计算处理函数去进行。目前准备了好几种弹幕的种类，就像用敌人行动模式的那样，使用函数指针进行调用。实际的计算就像下面这样。（对上面的程序的一个补充）———————————————————————————————————————————————————————————— 123456789101112131415161718192021222324252627//--- shot.cpp 添加如下代码 ---void shot_calc(int n)&#123; int i,max=0; if(enemy[shot[n].num].flag!=1)//敌人被打倒了的话 shot[n].flag=2;//从此不再发射子弹 for(i=0;i&lt;SHOT_BULLET_MAX;i++)&#123;//计算第n个弹幕数据 if(shot[n].bullet[i].flag&gt;0)&#123;//这个子弹数据注册了的话 shot[n].bullet[i].x+=cos(shot[n].bullet[i].angle)*shot[n].bullet[i].spd; shot[n].bullet[i].y+=sin(shot[n].bullet[i].angle)*shot[n].bullet[i].spd; shot[n].bullet[i].cnt++; if(shot[n].bullet[i].x&lt;-50 || shot[n].bullet[i].x&gt;FIELD_MAX_X+50 || shot[n].bullet[i].y&lt;-50 || shot[n].bullet[i].y&gt;FIELD_MAX_Y+50)&#123;//移动出画面了的话 if(shot[n].bullet[i].till&lt;shot[n].bullet[i].cnt)//已经超过至少需要显示的时间的话 shot[n].bullet[i].flag=0;//清除 &#125; &#125; &#125; //查询现在有没有正在被展示的弹幕 for(i=0;i&lt;SHOT_BULLET_MAX;i++) if(shot[n].bullet[i].flag&gt;0) return; if(enemy[shot[n].num].flag!=1)&#123; shot[n].flag=0;//结束 enemy[shot[n].num].flag=0; &#125;&#125; —————————————————————————————————————————————————————————————————————————— 在弹幕的main 函数里，根据传进来的弹幕编号 n ， 计算第n个的弹幕数据。弹幕数据里面，有SHOT_BULLET_MAX 个子弹，并且对其中注册了的数据进行计算。假如敌人已经被击倒了还能发射子弹的话，这是不科学的。所以我们在敌人被击破了以后，就不再进行子弹的注册。于是，敌人被击破了以后，我们要设置两个标志。如果画面中，一个子弹也没有的话，就结束弹幕。接下来，Hard难度下的 0 号弹幕的计算，在shotH.cpp 的 shot_bullet_H000 里，就像下面这样进行计算。———————————————————————————————————————————————————————————————————— 12345678910111213141516171819//--- shotH.cpp 里添加如下代码 ---void shot_bullet_H000(int n)&#123; int k; if(shot[n].cnt==0)&#123;//弹幕编号从0开始 //敌人还没有被打倒，并且找到的可注册子弹编号是有效的的话 if(shot[n].flag!=2 &amp;&amp; (k=shot_search(n))!=-1)&#123; shot[n].bullet[k].knd =enemy[shot[n].num].blknd2;//子弹的种类 shot[n].bullet[k].angle =shotatan2(n);//角度 shot[n].bullet[k].flag =1;//标志 shot[n].bullet[k].x =enemy[shot[n].num].x;//坐标 shot[n].bullet[k].y =enemy[shot[n].num].y; shot[n].bullet[k].col =enemy[shot[n].num].col;//颜色 shot[n].bullet[k].cnt =0;//计数 shot[n].bullet[k].spd =3;//速度 se_flag[0]=1;//给子弹的发射音效做的标志 &#125; &#125;&#125; ————————————————————————————————————————————————————————————————————————shot[n].num 是已经注册的敌机数据的识别编号，可以对enemy进行对应，像上面这样使用。然后，最后的se_flag[0]=1， 是播放子弹的发射音效用的。音乐的管理统一放在一个地方进行，这里只是先设置一个标志而已。music.cpp文件里，添加下面的两个函数。———————————————————————————————————————————————————————————————————————— 12345678910111213//--- music.cpp 里添加如下代码 ---void music_ini()&#123; memset(se_flag,0,sizeof(int)*SE_MAX);&#125;void music_play()&#123; int i; for(i=0;i&lt;SE_MAX;i++)&#123; if(se_flag[i]==1) PlaySoundMem(sound_se[i],DX_PLAYTYPE_BACK); &#125;&#125; ————————————————————————————————————————————————————————————————————————在music_ini() 里面，在循环的开始的时候，把所有的flag标志都设置为0。然后在循环结束的时候，在music_play()里，就对设置了flag标记的音效进行播放。所以，PlaySoundMem 统一进行音乐的播放，这样管理和检查错误都会变的更容易一些。然后，给shot.cpp里增加的函数添加声明，方便从别的地方进行调用。———————————————————————————————————————————————————————————————————————— 1234567891011121314151617181920212223242526//--- function.h 里添加如下代码 ---//shot.cpp GLOBAL double shotatan2(int n); GLOBAL int shot_search(int n); GLOBAL void shot_main();//music.cpp GLOBAL void music_ini(); GLOBAL void music_play();//--- load.cpp 里添加如下代码 --- //读取子弹的图像文件 LoadDivGraph( \"../dat/img/bullet/b0.png\" , 5 , 5 , 1 , 76 , 76 , img_bullet[0] ) ; LoadDivGraph( \"../dat/img/bullet/b1.png\" , 6 , 6 , 1 , 22 , 22 , img_bullet[1] ) ; LoadDivGraph( \"../dat/img/bullet/b2.png\" , 10 , 10 , 1 , 5 , 120 , img_bullet[2] ) ; LoadDivGraph( \"../dat/img/bullet/b3.png\" , 5 , 5 , 1 , 19 , 34 , img_bullet[3] ) ; LoadDivGraph( \"../dat/img/bullet/b4.png\" , 10 , 10 , 1 , 38 , 38 , img_bullet[4] ) ; LoadDivGraph( \"../dat/img/bullet/b5.png\" , 3 , 3 , 1 , 14 , 16 , img_bullet[5] ) ; LoadDivGraph( \"../dat/img/bullet/b6.png\" , 3 , 3 , 1 , 14 , 18 , img_bullet[6] ) ; LoadDivGraph( \"../dat/img/bullet/b7.png\" , 9 , 9 , 1 , 16 , 16 , img_bullet[7] ) ; LoadDivGraph( \"../dat/img/bullet/b8.png\" , 10 , 10 , 1 , 12 , 18 ,img_bullet[8] ) ; LoadDivGraph( \"../dat/img/bullet/b9.png\" , 3 , 3 , 1 , 13 , 19 , img_bullet[9] ) ; //读取敌机的射击音效 sound_se[0]=LoadSoundMem(\"../dat/se/enemy_shot.wav\"); ————————————————————————————————————————————————————————————————————————最后是子弹的显示。一个弹幕数据(shot)中的子弹(bullet)如果发射了的话，flag标志就会设置为开启。对数组中的所有标志进行遍历，flag 如果设置为开启，就对那种子弹进行表示。这里对“线性插值绘图”，进行一个简单易懂的介绍，设置了这种画图方式后，比如像“在坐标为1.5像素点进行绘图”这种，想表示的位置里含有小数点的情况下，能够在中间进行漂亮的补间绘画。这里，想象一下初中就学过的一次函数 y=10x 的函数图像。是一条倾斜的很厉害的右上方向的斜线。按这样的方向射击，不考虑小数点的在像素上进行移动的话，我们可以想象到会出现不平滑的移动。所以这里调用这种线性函数进行描绘，可以对中间进行平滑的补间描绘。———————————————————————————————————————————————————————————————————————— 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//--- graph.cpp 里添加如下代码 ---//子弹的描绘void graph_bullet()&#123; int i,j; SetDrawMode( DX_DRAWMODE_BILINEAR ) ;//线性插值描绘 for(i=0;i&lt;SHOT_MAX;i++)&#123;//对敌人的弹幕数循环 if(shot[i].flag&gt;0)&#123;//弹幕数据标志是开启的话 for(j=0;j&lt;SHOT_BULLET_MAX;j++)&#123;//对这个弹幕所拥有的最大弹幕数进行循环 if(shot[i].bullet[j].flag!=0)&#123;//子弹数据标志是开启的话 if(shot[i].bullet[j].eff==1) SetDrawBlendMode( DX_BLENDMODE_ADD, 255) ; DrawRotaGraphF( shot[i].bullet[j].x+FIELD_X, shot[i].bullet[j].y+FIELD_Y, 1.0, shot[i].bullet[j].angle+PI/2, img_bullet[shot[i].bullet[j].knd][shot[i].bullet[j].col],TRUE); if(shot[i].bullet[j].eff==1) SetDrawBlendMode( DX_BLENDMODE_NOBLEND, 0) ; &#125; &#125; &#125; &#125; SetDrawMode(DX_DRAWMODE_NEAREST);//退出描绘形式&#125;//--- graph.cpp 里添加下面红字部分 ---void graph_main()&#123; graph_enemy(); graph_ch(); graph_bullet(); graph_board();&#125;//--- load.cpp 红字部分进行更改 ---//从Excel读取敌人的出现数据并储存的函数void load_story()&#123; int n,num,i,fp; char fname[32]=&#123;\"../dat/csv/13章/storyH0.csv\"&#125;; int input[64]; char inputc[64]; fp = FileRead_open(fname);//读取文件 if(fp == NULL)&#123; printfDx(\"read error\\n\"); return; &#125; —————————————————————————————————————————————————————————————————————————— 运行结果：http://dixq.net/rp/swf/13.swf 像运行结果那样，有各种各样的行动方式的敌人的话，就成功了。 （2014-2-18 笔记：这节给敌人加上射击功能，现在回顾一下，理一理逻辑怎么实现的。在敌机操作的 enemy_act 里面添加一个，到了射击时间就进行弹幕载入的功能。在 shot[SHOT_MAX] 里，找个flag 为空的，设置弹幕标记，子弹种类，敌机编号。然后主函数里，添加了弹幕的主函数 shot_main() 对所有弹幕进行更新操作。包含 shot_bullet （弹幕模式）和 shot_calc （子弹移动）shot[i].knd 对应一种弹幕类型，在这里的弹幕模式shot_bullet_H000() ，在shot[n] 里找到一个bullet ，这是子弹，类型设置为 blknd2，设置坐标为敌机，角度向自机。然后子弹移动里，对这个弹幕下的所有子弹的坐标进行更新，若超出范围则移除。 这下逻辑算是懂了，shot 是弹幕，每个弹幕里有bullet[n] ，这是这个弹幕的子弹。shot 弹幕的类型，是enemy[i].blknd ， 而弹幕子弹的类型是enemy[shot[n].num].blknd2敌机到点，是发射弹幕。 弹幕模式函数里，会自己根据需要加子弹） 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第12章、来制作大量敌人的行动模式吧","date":"2013-12-17T05:19:00.000Z","path":"2013/12/17/【四圣龙神录的编程教室】第12章、来制作大量敌人的行动模式吧/","text":"原文地址：http://dixq.net/rp/12.html 上一篇里，一个敌人的移动操作的函数已经做好了。现在我们来做更多的敌人移动吧。我们来做一个有0-10 的11种行动模式的操作函数吧。另外，这里写了一个叫做rang的函数。这个函数读取一个参数n，返回从 -n 到 n 的随机 double类型的数。下面代码很长，但都是很简单的函数的重复。 —————————————————————————————————————————————————————————————————————————— 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153//--enemy_act_pattern.cpp 的改动--#include \"../include/GV.h\"//根据传进的参数，返回-ang～ang的随机角度数double rang(double ang)&#123; return ( -ang + ang*2 * GetRand(10000)/10000.0 );&#125;//移动模式0//下落一段，停滞一会，然后上升void enemy_pattern0(int i)&#123; int t=enemy[i].cnt; if(t==0) enemy[i].vy=3;//下落 if(t==40) enemy[i].vy=0;//停止 if(t==40+enemy[i].wait)//停止时间结束 enemy[i].vy=-3;//往上移动&#125;//移动模式1//下落一段，停滞一会，然后往左下方移动void enemy_pattern1(int i)&#123; int t=enemy[i].cnt; if(t==0) enemy[i].vy=3;//下落 if(t==40) enemy[i].vy=0;//停止 if(t==40+enemy[i].wait)&#123;//停止时间结束 enemy[i].vx=-1;//往左 enemy[i].vy=2;//往下移动 enemy[i].muki=0;//设置朝向为左 &#125;&#125;//移动模式2//下落一段，停滞一会，然后往右下方移动void enemy_pattern2(int i)&#123; int t=enemy[i].cnt; if(t==0) enemy[i].vy=3;//下落 if(t==40) enemy[i].vy=0;//停止 if(t==40+enemy[i].wait)&#123;//停止时间结束 enemy[i].vx=1;//往右 enemy[i].vy=2;//往下移动 enemy[i].muki=2;//设置朝向为右 &#125;&#125;//移动模式3//快速的下落，并往左移动void enemy_pattern3(int i)&#123; int t=enemy[i].cnt; if(t==0) enemy[i].vy=5;//下落 if(t==30)&#123;//途中设置朝向为左 enemy[i].muki=0; &#125; if(t&lt;100)&#123; enemy[i].vx-=5/100.0;//向左加速 enemy[i].vy-=5/100.0;//减速 &#125;&#125;//移动模式4//快速下落，并向右移动void enemy_pattern4(int i)&#123; int t=enemy[i].cnt; if(t==0) enemy[i].vy=5;//下落 if(t==30)&#123;//途中设置朝向为右 enemy[i].muki=2; &#125; if(t&lt;100)&#123; enemy[i].vx+=5/100.0;//向右加速 enemy[i].vy-=5/100.0;//减速 &#125;&#125;//移动模式5//斜向左下void enemy_pattern5(int i)&#123; int t=enemy[i].cnt; if(t==0)&#123; enemy[i].vx-=1; enemy[i].vy=2; enemy[i].muki=0; &#125;&#125;//移动模式6//斜向右下void enemy_pattern6(int i)&#123; int t=enemy[i].cnt; if(t==0)&#123; enemy[i].vx+=1; enemy[i].vy=2; enemy[i].muki=2; &#125;&#125;//移动模式7//停滞一会，然后就往左上移动void enemy_pattern7(int i)&#123; int t=enemy[i].cnt; if(t==enemy[i].wait)&#123;//停止时间结束 enemy[i].vx=-0.7;//往左 enemy[i].vy=-0.3;//往上移动 enemy[i].muki=0;//设置朝向为左 &#125;&#125;//移动模式8//停滞一会，然后就往右上移动void enemy_pattern8(int i)&#123; int t=enemy[i].cnt; if(t==enemy[i].wait)&#123;//停止时间结束 enemy[i].vx=+0.7;//往右 enemy[i].vy=-0.3;//往上移动 enemy[i].muki=2;//设置朝向为右 &#125;&#125;//移动模式9//停滞一会，然后就往上移动void enemy_pattern9(int i)&#123; int t=enemy[i].cnt; if(t==enemy[i].wait)//停止时间结束 enemy[i].vy=-1;//往上移动&#125;//移动模式10//往下移动，然后转来转去的向上移动void enemy_pattern10(int i)&#123; int t=enemy[i].cnt; if(t==0) enemy[i].vy=4;//下落 if(t==40)enemy[i].vy=0;//停止 if(t&gt;=40)&#123; if(t%60==0)&#123; int r=cos(enemy[i].ang)&lt; 0 ? 0 : 1; enemy[i].sp=6+rang(2); enemy[i].ang=rang(PI/4)+PI*r; enemy[i].muki=2-2*r; &#125; enemy[i].sp*=0.95; &#125; if(t&gt;=40+enemy[i].wait)&#123; enemy[i].vy-=0.05; &#125;&#125; ——————————————————————————————————————————————————————————————————————————总之，我们来看看我们写的这个函数会做出什么样的动作吧。在Excel 里按照下面进行改动。直接下载来代替也是可以的。 /カウンタ移動パターン敵の種類x座標y座標スピード発射時間弾幕種類弾の色体力弾種類待機時間アイテム123456/cntpatternkndxyspbltimeblkndcolhpblknd2waititem_n 10000180-2001500010001200-1-1-1-1-118010200-2001500010001200-1-1-1-1-126020180-2001500010001200-1-1-1-1-134030200-2001500010001200-1-1-1-1-142040180-2001500010001200-1-1-1-1-150050200-2001500010001200-1-1-1-1-158060180-2001500010001200-1-1-1-1-16607020015001500010001200-1-1-1-1-17408018015001500010001200-1-1-1-1-18209020015001500010001200-1-1-1-1-1900100180-2001500010003600-1-1-1-1-1Excel文件的下载这里，敌人的行动模式存在enemy[i].pattern 数据里面，要根据存在这里的0-10 的这样的值，自动调用 函数enemy_pattern0 ~ 函数 enemy_pattern10 ，这要怎么做呢？这里就要使用叫做函数指针的东西了。(*enemy_pattern[ENEMY_PATTERN_MAX])(int) = { enemy_pattern0, enemy_pattern1, …..像这样，把对应的函数的地址代入进去。之后，把对应元素编号，用之前的 enemy[i].pattern 来指定，就可以调用处理了。实际使用了函数指针来调用的函数，就是下面的红字部分（颜色我省了）。—————————————————————————————————————————————————————————————————— 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//--enemy.cpp里添加如下代码--#include \"../include/GV.h\"#define ENEMY_PATTERN_MAX 11extern void enemy_pattern0(int);extern void enemy_pattern1(int);extern void enemy_pattern2(int);extern void enemy_pattern3(int);extern void enemy_pattern4(int);extern void enemy_pattern5(int);extern void enemy_pattern6(int);extern void enemy_pattern7(int);extern void enemy_pattern8(int);extern void enemy_pattern9(int);extern void enemy_pattern10(int);void (*enemy_pattern[ENEMY_PATTERN_MAX])(int) = &#123; enemy_pattern0, enemy_pattern1, enemy_pattern2, enemy_pattern3, enemy_pattern4, enemy_pattern5, enemy_pattern6, enemy_pattern7, enemy_pattern8, enemy_pattern9, enemy_pattern10,&#125;;//搜索空闲的敌机编号int enemy_num_search()&#123; for(int i=0;i&lt;ENEMY_MAX;i++)&#123;//根据flag，寻找空闲的enemy if(enemy[i].flag==0)&#123; return i;//返回可以使用的编号 &#125; &#125; return -1;//全部都被使用了的话，返回错误信息&#125;//敌机数据的载入void enemy_enter()&#123;//敌机的行动数据载入和操作的函数 int i,j,t; for(t=0;t&lt;ENEMY_ORDER_MAX;t++)&#123; if(enemy_order[t].cnt==stage_count)&#123;//到了开始移动的时间 if((i=enemy_num_search())!=-1)&#123; enemy[i].flag =1;//标志 enemy[i].cnt =0;//计数 enemy[i].pattern=enemy_order[t].pattern;//移动模式 enemy[i].muki =1;//方向 enemy[i].knd =enemy_order[t].knd;//敌机种类 enemy[i].x =enemy_order[t].x;//坐标 enemy[i].y =enemy_order[t].y; enemy[i].sp =enemy_order[t].sp;//速度 enemy[i].bltime =enemy_order[t].bltime;//子弹的发射时间 enemy[i].blknd =enemy_order[t].blknd;//弹幕的种类 enemy[i].blknd2 =enemy_order[t].blknd2;//子弹的种类 enemy[i].col =enemy_order[t].col;//颜色 enemy[i].wait =enemy_order[t].wait;//停止时间 enemy[i].hp =enemy_order[t].hp;//体力 enemy[i].hp_max =enemy[i].hp;//体力最大值 enemy[i].vx =0;//水平方向的分速度 enemy[i].vy =0;//竖直方向的分速度 enemy[i].ang =0;//角度 for(j=0;j&lt;6;j++) enemy[i].item_n[j]=enemy_order[t].item_n[j];//掉落的道具 &#125; &#125; &#125;&#125;//敌机的行动操作void enemy_act()&#123; int i; for(i=0;i&lt;ENEMY_MAX;i++)&#123; if(enemy[i].flag==1)&#123;//这个敌机的标志设置为开启的话 if(0&lt;=enemy[i].pattern &amp;&amp; enemy[i].pattern&lt;ENEMY_PATTERN_MAX)&#123; enemy_pattern[enemy[i].pattern](i); //这行是红字。。。 enemy[i].x+=cos(enemy[i].ang)*enemy[i].sp; enemy[i].y+=sin(enemy[i].ang)*enemy[i].sp; enemy[i].x+=enemy[i].vx; enemy[i].y+=enemy[i].vy; enemy[i].cnt++; enemy[i].img=enemy[i].muki*3+(enemy[i].cnt%18)/6; //敌机已经移动到画面之外的话进行消除 if(enemy[i].x&lt;-20 || FIELD_MAX_X+20&lt;enemy[i].x || enemy[i].y&lt;-20 || FIELD_MAX_Y+20&lt;enemy[i].y) enemy[i].flag=0; &#125; else printfDx(\"enemy[i].pattern的%d值不正确。\",enemy[i].pattern); &#125; &#125;&#125;//敌机处理的main方法void enemy_main()&#123; enemy_enter(); enemy_act();&#125; ——————————————————————————————————————————————————————————————————为了后面的角度计算方便，这里先把圆周率给定义一下。圆周率的 pi 和 2*pi 都会用到，这里预先把乘好的值也定义下来。——————————————————————————————————————————————————————————————————–define.h里添加如下代码– //圆周率 #define PI 3.1415926535898 #define PI2 (PI*2)——————————————————————————————————————————————————————————————————运行结果http://dixq.net/rp/swf/12.swf像运行结果里，有各种各样行动方式的敌人出现的话，就成功了。 （PS：最近玩剑灵，所以好久没更新了。唉，进了这DT的游戏公司，回去都12点了，再玩会剑灵，没别的时间了）（2014-2-18 笔记，这篇结合上一篇的笔记，就很好懂了。这篇只是新增了几个敌机的移动模式而已。然后用指针数组，根据i 找到对应的模式函数。然后具体分析里面的模式，其实都比较好懂，在某个时间点改变x y 方向的速度什么的。然后就是最后一种模式，可以仔细看看。这里用的是角度和速度，来控制移动的。而enemy_act 函数里面，先是根据角度移动，然后是根据x y 速度分量移动。 所以两种移动方式都会有效的，会叠加起来。估计这里这样设计的好处，就是某些地方，适合极坐标的时候，就只用角度来进行移动，方便弹幕的绘制） 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第11章、用Excel制作敌人的登场数据吧","date":"2013-12-01T16:35:00.000Z","path":"2013/12/02/【四圣龙神录的编程教室】第11章、用Excel制作敌人的登场数据吧/","text":"原文地址：http://dixq.net/rp/11.html 道中会有大量的敌人出现。然后敌人身上带有大量的数据。至少也有下面这些数据吧。 ———————————————————————————————————————————————————————————————————————————— –struct.h 里添加如下代码– typedef struct{ //计数、移动模式、敌人种类 int cnt,pattern,knd; //初始坐标和移动速度 double x,y,sp; //弹幕开始时间、弹幕的种类、颜色、体力、弹幕的种类、停滞时间、掉落道具(6种) int bltime,blknd,col,hp,blknd2,wait,item_n[6];}enemy_order_t;————————————————————————————————————————————————————————————————————————————这是敌人出现相关的构造体。在什么时候，什么地方，什么样的敌人，发射什么样的子弹过来，停留在什么位置，是否回回去……等等这些数据必须要很多变量来指定才行。但是，当计数到112时，x坐标在这里，y坐标在这里，移动模式是这样，当计数到187这个又是那样的……要手动输入这些数据，然后存入指定的变量，是很困难的一件事。所以，我们用Excel来制作敌人出现的数据吧。首先，从这里下载用 Excel 制作的敌人出现的数据文件。下载Excel数据在dat文件夹里下，建立一个 csv 文件夹，然后把文件放进去。内容大概是这样的。 如果是没有Excel的话，使用文本编辑工具，也可以打开看到里面的内容的。首先，最左边是敌人出现的时间。在 60fps 运行的游戏里面，60 就等于1秒。也就是说，这里的第一个敌人，在游戏开始后的1.6秒出现，这样的意思。然后过了 10 个计数，也就是1/6 秒，下一个敌人就出现了。敌人的数据，除了x坐标，其他都是一样的。在Excel 里要制作按同样变化增加的值是很方便的事情。然后，在DxLib里，文件读取是要使用DxLib的函数的（为了使用存档文件）如果DxLib 的文件读取函数的使用方法有不清楚的地方的话，去它的主页学习一下吧。基本上和C的标准函数 fopen(←这个稍微有点不同）和 fgetc 差不多的使用方法。另外，虽然可能对csv文件没有准备，但只要用文本编辑器打开一看，我想应该就能看明白了。只是用逗号来区分单元格，只要读取进来按照逗号来区分，就和普通的文本读取方式差不多。那么我们就写一下这个读入的函数。下面是把存了敌人出现的数据的 enemy_order 的excel 文件读取进来，存入变量的函数。这个没有必要去特别的理解，只要知道这个是把数据存到变量里面的就行了。————————————————————————————————————————————————————————————————————————————–load.cpp 里加入下面语句– 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//把敌人出现的数据从Excel里读取出来并保存的函数void load_story()&#123; int n,num,i,fp; char fname[32]= &#123;\"../dat/csv/storyH0.csv\"&#125;; int input[64]; char inputc[64]; fp = FileRead_open(fname);//读取文件 if(fp == NULL) &#123; printfDx(\"read error\\n\"); return; &#125; for(i=0; i&lt;2; i++) //跳过最开始的两行 while(FileRead_getc(fp)!='\\n'); n=0 , num=0; while(1) &#123; for(i=0; i&lt;64; i++) &#123; inputc[i]=input[i]=FileRead_getc(fp);//取得一个字符 if(inputc[i]=='/') //如果是斜线 &#123; while(FileRead_getc(fp)!='\\n');//循环读取到行尾 i=-1;//count 回到最开始 continue; &#125; if(input[i]==',' || input[i]=='\\n') //如果是逗号或者换行 &#123; inputc[i]='\\0'; //到这里作为一个字符串 break; &#125; if(input[i]==EOF) //到文件末尾的话 &#123; goto EXFILE; //结束 &#125; &#125; switch(num)&#123; case 0: enemy_order[n].cnt =atoi(inputc);break; case 1: enemy_order[n].pattern =atoi(inputc);break; case 2: enemy_order[n].knd =atoi(inputc);break; case 3: enemy_order[n].x =atof(inputc);break; case 4: enemy_order[n].y =atof(inputc);break; case 5: enemy_order[n].sp =atof(inputc);break; case 6: enemy_order[n].bltime =atoi(inputc);break; case 7: enemy_order[n].blknd =atoi(inputc);break; case 8: enemy_order[n].col =atoi(inputc);break; case 9: enemy_order[n].hp =atoi(inputc);break; case 10:enemy_order[n].blknd2 =atoi(inputc);break; case 11:enemy_order[n].wait =atoi(inputc);break; case 12:enemy_order[n].item_n[0]=atoi(inputc);break; case 13:enemy_order[n].item_n[1]=atoi(inputc);break; case 14:enemy_order[n].item_n[2]=atoi(inputc);break; case 15:enemy_order[n].item_n[3]=atoi(inputc);break; case 16:enemy_order[n].item_n[4]=atoi(inputc);break; case 17:enemy_order[n].item_n[5]=atoi(inputc);break; &#125; num++; if(num==18) &#123; num=0; n++; &#125; &#125;EXFILE: FileRead_close(fp);&#125; ————————————————————————————————————————————————————————————————————————————等你理解了这个，太阳都下山了。我们赶紧把这个先放下，去做后面的吧。在进入具体的处理之前，我们先整理一下详细的改动吧。ini.cpp里，对我们刚添加的结构，使用初始化函数来进行初始化。define.h里，定义最多可显示的敌机数量。GV.h里，准备好要用的变量。————————————————————————————————————————————————————————————————————————————–ini.cpp 的ini函数里，加入下面的代码– memset(enemy_order,0,sizeof(enemy_order_t)*ENEMY_ORDER_MAX); –define.h 里，添加如下代码– //敌机出现的最大数目 #define ENEMY_ORDER_MAX 500 –GV.h 里添加如下代码– GLOBAL enemy_order_t enemy_order[ENEMY_ORDER_MAX];//敌机的出现的数据 –function.h 里添加如下代码– GLOBAL void load_story(); –main.cpp 里的main函数的switch里面的下面部分进行改动– case 99://STG开始前的初始化 ini(); load_story(); func_state=100; break;————————————————————————————————————————————————————————————————————————————接下来，就是把这次敌人出现的数据放到 enemy_order 里面去了。把储存在这里的数据，放到下面的实际出现在游戏中的敌机，看看他们的显示吧。enemy_enter 是敌机的注册。enemy_order[n].cnt 是他出现的时间，这个和游戏里面的计数器一样的时候，敌机数据的载入就进行了。敌机数据进行注册的时候，会调用一个叫做 enemy_num_search 的函数进行调查哪个编号的是空的。这个函数会告诉我们，在有储存敌机数据的 enemy 数组元素里面，从 0 到ENEMY_MAX-1 哪个编号还没有使用。如果全部位置都是有数据的，那么就返回-1，这个时候就不能再注册新的敌机了。另外，enemy[n].wait 就像上面说的那样，是代表停滞时间的。可以像下面红字那样使用。（颜色不标了）也就是操作敌机停滞的时间用的。敌人的移动计算，有两种方式。用 角度ang 和 速度大小sp 组合来计算的，或者是 速度x分量vx，和速度y 分量vy来计算的。这两种方式根据不同的情况，用途也不一样。当然，这次的 enemy_pattern 所使用的vy=2 ，也可以转换成 ang = 3.14/2 和 sp=2 , 但前者使用起来更方便。————————————————————————————————————————————————————————————————————————————–enemy.cpp 的改动 – 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include \"../include/GV.h\"//敌机的移动模式0 的移动操作void enemy_pattern0(int i)&#123; int t=enemy[i].cnt; if(t==0) enemy[i].vy=2; //往下移动 if(t==60) enemy[i].vy=0; //停下来 if(t==60+enemy[i].wait) //停止时间过了 enemy[i].vy=-2;//向上移动&#125;//检索空着的敌机编号int enemy_num_search()&#123; for(int i=0; i&lt;ENEMY_MAX; i++) //搜索没有标记flag的元素 &#123; if(enemy[i].flag==0) &#123; return i;//返回可以用的编号 &#125; &#125; return -1;//全部都储存了的话，返回-1&#125;//敌机数据载入void enemy_enter() //敌机行动的注册，操作函数&#123; int i,j,t; for(t=0; t&lt;ENEMY_ORDER_MAX; t++) &#123; if(enemy_order[t].cnt==stage_count) //现在的时间正好是 敌人出现顺序的时间 &#123; if((i=enemy_num_search())!=-1) &#123; enemy[i].flag =1;//标记 enemy[i].cnt =0;//计数 enemy[i].pattern=enemy_order[t].pattern;//移动模式 enemy[i].muki =1;//方向 enemy[i].knd =enemy_order[t].knd;//敌人种类 enemy[i].x =enemy_order[t].x;//坐标 enemy[i].y =enemy_order[t].y; enemy[i].sp =enemy_order[t].sp;//速度 enemy[i].bltime =enemy_order[t].bltime;//子弹的发射时间 enemy[i].blknd =enemy_order[t].blknd;//弹幕种类 enemy[i].blknd2 =enemy_order[t].blknd2;//子弹类型 enemy[i].col =enemy_order[t].col;//颜色 enemy[i].wait =enemy_order[t].wait;//停滞时间 enemy[i].hp =enemy_order[t].hp;//体力 enemy[i].hp_max =enemy[i].hp;//体力最大值 enemy[i].vx =0;//水平方向的速度 enemy[i].vy =0;//竖直方向的速度 enemy[i].ang =0;//角度 for(j=0; j&lt;6; j++) enemy[i].item_n[j]=enemy_order[t].item_n[j];//掉落的道具 &#125; &#125; &#125;&#125;//敌机的行动操作void enemy_act()&#123; int i; for(i=0; i&lt;ENEMY_MAX; i++) &#123; if(enemy[i].flag==1) //标记设置为ON &#123; enemy_pattern0(i); enemy[i].x+=cos(enemy[i].ang)*enemy[i].sp; enemy[i].y+=sin(enemy[i].ang)*enemy[i].sp; enemy[i].x+=enemy[i].vx; enemy[i].y+=enemy[i].vy; enemy[i].cnt++; enemy[i].img=enemy[i].muki*3+(enemy[i].cnt%18)/6; //敌人从画面中消失 if(enemy[i].x&lt;-20 || FIELD_MAX_X+20&lt;enemy[i].x || enemy[i].y&lt;-20 || FIELD_MAX_Y+20&lt;enemy[i].y) enemy[i].flag=0; &#125; &#125;&#125;//敌机处理的main方法void enemy_main()&#123; enemy_enter(); enemy_act();&#125; ————————————————————————————————————————————————————————————————————————————运行结果：http://dixq.net/rp/swf/11.swf 连续的敌人掉下来，过一会上升的话，就对了。 （个人笔记：首先，load 里面，读取excel 表格里的内容，这记录着敌机登场的数据。然后在enemy_enter 里，到了点就读取对应的敌机数据，让敌机登场。然后enemy_act 里面，首先调用敌机的行动模式函数，其中可以调整速度和方向等，然后对敌机的坐标，计数进行更新。 就是酱紫） 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第10章、把敌人表示出来看看吧","date":"2013-11-26T16:48:00.000Z","path":"2013/11/27/【四圣龙神录的编程教室】第10章、把敌人表示出来看看吧/","text":"原文地址：http://dixq.net/rp/10.html 既然是做STG射击游戏，肯定想快点写弹幕呢，是吧。要做弹幕的数据的话，首先得把敌人的数据给做出来呢，我们赶紧来制作吧。 ————————————————————————————————————————————————————————————————————————————–struct.h 里加入如下代码– //敌人相关的构造体typedef struct{ //标志、计数、移动模式、方向、敌人种类、HP、HP最大值、掉落道具、图像 int flag,cnt,pattern,muki,knd,hp,hp_max,item_n[6],img; //坐标、速度的x分量、速度的y分量、速度、角度 double x,y,vx,vy,sp,ang; //弹幕开始时间、弹幕的种类、子弹的种类、颜色、状态、待机时间、停滞时间 int bltime,blknd,blknd2,col,state,wtime,wait;}enemy_t;————————————————————————————————————————————————————————————————————————————这都什么东西啊！！虽然这么多变量混在一起，但没必要把他们全部都记住。flag 是标志，cnt 是计数，pattern是敌机的移动模式，就这样用能表示含义的变量名，在想这个是什么变量的时候，能根据名字直接联想出来就好了。由于敌人必须带有很多各种各样的信息，所以这里定义了很多的变量，不过这并不是什么很难的东西。我们把用来表示游戏中的计数的 stage_count 变量，和保存敌机图像的 img_enemy 变量先准备好。在 define 里，把表示可以同时显示的敌机最大数量设置为30，定义在ENEMY_MAX 里面。—————————————————————————————————————————————————————————————————————————————–GV.h 里加入下面代码– GLOBAL int stage_count;GLOBAL int img_enemy[3][9];//9张敌机图像 X3份GLOBAL enemy_t enemy[ENEMY_MAX]; –define.h 里加入下面代码– //敌机的同时显示的最大数量 #define ENEMY_MAX 30 –load.cpp 里加入下面代码– LoadDivGraph( “../dat/img/enemy/0.png” , 9 , 3 , 3 , 32 , 32 , img_enemy[0] ) ;—————————————————————————————————————————————————————————————————————————————初始化函数分为，启动之后，可以多次执行的初始化，和只在游戏刚开始就得进行的初始化这两种。下面举个例子吧，键位的初始设置等等，在游戏刚开始的时候就不是必须得执行的，但自机的数据，敌机的数据的初始化等等，在游戏刚开始时就必须执行。—————————————————————————————————————————————————————————————————————————————–ini.cpp改动– 1234567891011121314151617181920212223#include \"../include/GV.h\"//最开始的初始化void first_ini()&#123; configpad.down=0; configpad.left=1; configpad.right=2; configpad.up=3; configpad.bom=4; configpad.shot=5; configpad.slow=11; configpad.start=13; configpad.change=6;&#125;//游戏的初始化void ini()&#123; stage_count=1; memset(&amp;ch,0,sizeof(ch_t));//自机数据的初始化 ch.x=FIELD_MAX_X/2; ch.y=FIELD_MAX_Y*3/4; memset(enemy,0,sizeof(enemy_t)*ENEMY_MAX);//敌机数据的初始化&#125; —————————————————————————————————————————————————————————————————————————————敌人数据的处理是个大的流程。当游戏计数到达某个点的时候，敌机就载入(enemy_enter)。如果有已经载入的敌机，就把敌机的移动模式(enemy_pattern)，传入对敌机进行移动的操作函数，进行敌机的移动。敌机移动画面外面的话，就把敌机载入的标志设置为假。大概就是这样的流程—————————————————————————————————————————————————————————————————————————————–enemy.cpp 改动– 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include \"../include/GV.h\"//敌机的移动模式0 的移动操作void enemy_pattern0(int i)&#123; if(enemy[i].cnt&lt;60)&#123; enemy[i].y+=2.0; &#125; if(enemy[i].cnt&gt;60+240)&#123; enemy[i].y-=2.0; &#125;&#125;//敌机数据载入void enemy_enter()&#123; if(stage_count==100)&#123; //从游戏开始后计数到了100时载入 enemy[0].cnt =0; enemy[0].muki =1; enemy[0].flag =1; enemy[0].bltime =150; enemy[0].hp =1000; enemy[0].hp_max =enemy[0].hp; enemy[0].pattern=0; enemy[0].x =FIELD_MAX_X/2; enemy[0].y =-20; &#125;&#125;//敌机的行动操作void enemy_act()&#123; int i; for(i=0;i&lt;ENEMY_MAX;i++)&#123; if(enemy[i].flag==1)&#123; //敌机的标志为开启状态 enemy_pattern0(i); enemy[i].cnt++; enemy[i].img=enemy[i].muki*3+(enemy[i].cnt%18)/6; //敌机从画面中消失 if(enemy[i].x&lt;-50 || FIELD_MAX_X+50&lt;enemy[i].x || enemy[i].y&lt;-50 || FIELD_MAX_Y+50&lt;enemy[i].y) enemy[i].flag=0; &#125; &#125;&#125;//敌机处理的main方法void enemy_main()&#123; enemy_enter(); enemy_act();&#125; —————————————————————————————————————————————————————————————————————————————绘画处理要增加的，只是对敌机数据的绘制而已。寻找载入了的敌机数据，对其进行绘制显示。——————————————————————————————————————————————————————————————————————–graph.cpp 的改动– 123456789101112131415161718192021222324252627#include \"../include/GV.h\"void graph_enemy()&#123; int i; for(i=0;i&lt;ENEMY_MAX;i++)&#123; if(enemy[i].flag==1)&#123; DrawRotaGraphF(enemy[i].x+FIELD_X,enemy[i].y+FIELD_Y,1.0f,0.0f,img_enemy[0][enemy[i].img],TRUE); &#125; &#125;&#125;void graph_ch()&#123; DrawRotaGraphF(ch.x+FIELD_X,ch.y+FIELD_Y,1.0f,0.0f,img_ch[0][ch.img],TRUE);&#125;void graph_board()&#123; DrawGraph( 0, 0,img_board[10],FALSE); DrawGraph( 0, 16,img_board[11],FALSE); DrawGraph( 0,464,img_board[12],FALSE); DrawGraph(416, 0,img_board[20],FALSE);&#125;void graph_main()&#123; graph_enemy(); graph_ch(); graph_board();&#125; ————————————————————————————————————————————————————————————————————————————main函数只改动了红色部分（这里就不标颜色了，主要在case 99 和100 的改动）—————————————————————————————————————————————————————————————————————————————–main.cpp 的改动– 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#define GLOBAL_INSTANCE#include \"../include/GV.h\"//主循环里必须做的三大处理int ProcessLoop()&#123; if(ProcessMessage()!=0) return -1 ; //Process处理出错的话，返回-1 if(ClearDrawScreen()!=0) return -1; //画面清理出错的话，返回-1 GetHitKeyStateAll_2(); //当前键盘输入处理 GetHitPadStateAll(); //当前手柄输入处理 return 0;&#125;int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)&#123; ChangeWindowMode(TRUE); //窗口模式 if(DxLib_Init() == -1 || SetDrawScreen( DX_SCREEN_BACK )!=0) return -1; //初始化和设置双缓冲模式 while(ProcessLoop()==0) //主循环 &#123; switch(func_state) &#123; case 0: //第一次进入时处理 load(); //载入数据 first_ini(); //第一次初始化 func_state=99; break; case 99: //射击游戏开始前的初始化 ini(); func_state=100; break; case 100: //一般的处理 calc_ch(); //计算角色的使用图片 ch_move(); //角色的移动操作 enemy_main(); //敌机处理的主函数 graph_main(); //主绘画函数 stage_count++; break; default: printfDx(\"未知的func_state\\n\"); break; &#125; if(CheckStateKey(KEY_INPUT_ESCAPE)==1) break; //按下ESC的话，break ScreenFlip(); //交换双缓冲画面 &#125; DxLib_End(); //DxLib中止 return 0;&#125; —————————————————————————————————————————————————————————————————————————————这次新增的函数还需要声明一下。——————————————————————————————————————————————————————————————————————————– function.h 里面添加如下代码 –GLOBAL void enemy_main();GLOBAL void ini();——————————————————————————————————————————————————————————————————————————运行结果：http://dixq.net/rp/swf/10.swf过一会，敌人会下落，然后过一会，敌人又往上升，就对了。 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第9章、试试操作人物的移动吧","date":"2013-11-24T13:16:00.000Z","path":"2013/11/24/【四圣龙神录的编程教室】第9章、试试操作人物的移动吧/","text":"原文地址：http://dixq.net/rp/9.html 让我们给角色加上在可移动范围之内可以上下左右任意移动的功能吧。当我们斜向移动的时候，如果不把速度减为1/根号2，那么移动速度就不是1倍的速度了斜着移动时，水平速度和竖直速度都需要进行变动。 ————————————————————————————————————————————————————————————————————————————— 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//--char.cpp的改动--#include \"../include/GV.h\"void calc_ch()&#123; ch.cnt++; ch.img=(ch.cnt%24)/6;&#125;void ch_move() //角色的移动操作&#123; int i,sayu_flag=0,joge_flag=0; double x,y,mx,my,naname=1; double move_x[4]= &#123;-4.0,4.0,0,0&#125;,move_y[4]= &#123;0,0,4.0,-4.0&#125;; //&#123;左,右,下,上&#125;的速度 int inputpad[4]; inputpad[0]=CheckStatePad(configpad.left); inputpad[1]=CheckStatePad(configpad.right); inputpad[2]=CheckStatePad(configpad.down); inputpad[3]=CheckStatePad(configpad.up); if(CheckStatePad(configpad.left)&gt;0) //按下左键的话 ch.img+=4*2; //使用往左移的角色图像 else if(CheckStatePad(configpad.right)&gt;0) //右键按下的话 ch.img+=4*1; //使用往右移的角色图像 for(i=0; i&lt;2; i++) //水平方向 if(inputpad[i]&gt;0) //左右键有一个按下的话 sayu_flag=1; //设置左右键按下标志 for(i=2; i&lt;4; i++) //竖直方向 if(inputpad[i]&gt;0) //上下键有一个按下的话 joge_flag=1; //设置竖直方向按下标志 if(sayu_flag==1 &amp;&amp; joge_flag==1)//水平和竖直都有键按下的话，说明是斜向移动 naname=sqrt(2.0); //移动速度变为1/根号2 for(int i=0; i&lt;4; i++) //分四个方向循环 &#123; if(inputpad[i]&gt;0) //i方向的键盘或者手柄有输入的话 &#123; x=ch.x , y=ch.y; //把当前的坐标先保存下来 mx=move_x[i]; my=move_y[i]; //移动量保存到mx和my if(CheckStatePad(configpad.slow)&gt;0) //如果是低速移动 &#123; mx=move_x[i]/3; my=move_y[i]/3; //移动速度变为1/3 &#125; x+=mx/naname , y+=my/naname; //当前坐标和移动量相加 if(!(x&lt;10 || x&gt;FIELD_MAX_X-10 || y&lt;5 || y&gt;FIELD_MAX_Y-5)) //计算结果在移动范围内的话 &#123; ch.x=x , ch.y=y; //进行实际的移动 &#125; &#125; &#125;&#125; ———————————————————————————————————————————————————————————————————————————— 因为要使用 sqrt 函数，我们把 math.h 包含进来。然后 ch_move 在 function.h 里添加一下。————————————————————————————————————————————————————————————————————————————–GV.h 里添加如下内容– #include “math.h” –function.h 添加如下内容– GLOBAL void ch_move();————————————————————————————————————————————————————————————————————————————main 函数里，加入下面这行。———————————————————————————————————————————————————————————————————————————— 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//--main.cpp改动-- #define GLOBAL_INSTANCE #include \"../include/GV.h\" //主循环里必须做的三大处理 int ProcessLoop() &#123; if(ProcessMessage()!=0) return -1 ; //Process处理出错的话，返回-1 if(ClearDrawScreen()!=0) return -1; //画面清理出错的话，返回-1 GetHitKeyStateAll_2(); //当前键盘输入处理 GetHitPadStateAll(); //当前手柄输入处理 return 0; &#125; int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow) &#123; ChangeWindowMode(TRUE); //窗口模式 if(DxLib_Init() == -1 || SetDrawScreen( DX_SCREEN_BACK )!=0) return -1; //初始化和设置双缓冲模式 while(ProcessLoop()==0) //主循环 &#123; switch(func_state) &#123; case 0: load(); //载入数据 first_ini(); //第一次初始化 func_state=100; break; case 100: calc_ch(); //计算角色的使用图片 ch_move(); //角色的移动操作 graph_main(); //主绘画函数 break; default: printfDx(\"未知的func_state\\n\"); break; &#125; if(CheckStateKey(KEY_INPUT_ESCAPE)==1) break; //按下ESC的话，break ScreenFlip(); //交换双缓冲画面 &#125; DxLib_End(); //DxLib中止 return 0; &#125; ————————————————————————————————————————————————————————————————————————————运行结果http://dixq.net/rp/swf/09.swf接上游戏手柄，按上下左右，然后键盘上方向键上下左右也按下，角色能像上图中这样移动的话就成功了 注：做一点简单解释吧。我刚写完也没看懂。 char.cpp 里面，ch.img+=4*2; 是设置 往左或者往右移时，角色的倾斜效果的图像的。由于GV.h 里 定义的 int img_ch[2][12]，而 load.cpp里把读入的12张图片放到 img_ch[0]，也就是img_ch[0][0] 到 img_ch[0][3] 这四张是普通状态的循环图4567，这四张是右移的图，89 10 11 是左移的图。原本 ch.img=(ch.cnt%24)/6 就是 cnt 在每变化到24 的周期里面，分别设置为 0 1 2 3所以上面的 +4 就 是设置为右移的一套图，+8就是左移的一套图。因为这个值，是先算出 0 1 2 3， 如果按下左右键，则设置左右移动图。 放开左右键，自动还是 0 1 2 3 的原始图。 然后关于移动 move_x 和 move_y 是移动分量，里面有负数的。所以代码里只管加就对了。下面的移动里，循环是分4个方向分别进行的。虽然代码里，x，y 都写了，但每次实际上是一个方向的移动处理，x，y有一个肯定移动量为0所以刚开始，我看最后如果移动出范围，则坐标不变。以为如果斜着移动出去，会不能动。这其实是多余的担心。斜着移动到边缘的时候，只有其中出去的那个分量走到最后保持坐标不变的逻辑。 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第8章、把按键的对应设置一下吧","date":"2013-11-24T11:41:00.000Z","path":"2013/11/24/【四圣龙神录的编程教室】第8章、把按键的对应设置一下吧/","text":"原文地址：http://dixq.net/rp/8.html 在STG游戏，键位设置是十分重要的。如果开始没有设置好，以后程序的代码可能全部都要改动，这是十分麻烦的，所以我们开始就把它设置好吧。首先，取得按键的输入状态。（这在前面的章节里已经做好了）然后，取得手柄摇杆的输入状态。为了要让键盘按键输入和摇杆输入相对应，把键盘输入状态，和手柄摇杆的输入在Config 设定好，让两方对应起来。这次，我们要使用叫做 GetJoypadInputState的函数，使用方法如果不清楚的话，去DxLib 的官网去查看一下吧。那么，手柄设置要用到的构造体，以及 定义为 16的PAD_MAX，就像如下这样定义。 —————————————————————————————————————————————————————————————————————————————–struct.h 里加上如下代码– //手柄相关的构造体typedef struct{ int key[PAD_MAX];}pad_t; //设置相关的构造体typedef struct{ int left,up,right,down,shot,bom,slow,start,change;}configpad_t;——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————–define.h 的变动– //活动范围的大小 #define FIELD_MAX_X 384 #define FIELD_MAX_Y 448//活动范围的左上角坐标 #define FIELD_X 32 #define FIELD_Y 16//手柄按键的最大数量 #define PAD_MAX 16 #include “struct.h”—————————————————————————————————————————————————————————————————————————————手柄使用的键位，在PAD_MAX 里准备了16个最大按键数量，总之，【上，下，左，右，射击，炸弹，低速，开始，变身】这样9个键先准备好。这些键，对应到0-15的的哪个数字，按自己的喜好来设定好，就可以使用手柄的键位了。手柄的键位对应的是哪个数字，请自己去确认一下。这里已经确认过了，通常是按照如下所示的序号使用的，在初始化函数里代入下面这些值吧。—————————————————————————————————————————————————————————————————————————————–ini.cpp的改动– #include “../include/GV.h” //最开始的初始化void first_ini(){ ch.x=FIELD_MAX_X/2; ch.y=FIELD_MAX_Y*3/4; configpad.down=0; configpad.left=1; configpad.right=2; configpad.up=3; configpad.bom=4; configpad.shot=5; configpad.slow=11; configpad.start=13; configpad.change=6;}——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————–GV.h 里加上下面的语句– GLOBAL configpad_t configpad;—————————————————————————————————————————————————————————————————————————————GetHitPadStateAll 函数会获得当前的手柄输入状态，然后和键盘输入状态相比较，采用输入时间更长的存入手柄的输入状态变量里。以上这两个函数没有改动。到时候，参数1和参数2选择更大的，作为参数1传入下面的函数void input_pad_or_key(int *p, int k)这个函数中使用的条件运算符的使用方法如果不清楚的话，去自己查一下吧。CheckStatePad 是在初始化函数里设定了的，根据传入的序号返回输入状态。和之前的CheckStateKey函数的机制是一样的。————————————————————————————————————————————————————————————————————————————— 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071--key.cpp 的改动--#include \"../include/GV.h\"unsigned int stateKey[256];int GetHitKeyStateAll_2()&#123; char GetHitKeyStateAll_Key[256]; GetHitKeyStateAll( GetHitKeyStateAll_Key ); for(int i=0; i&lt;256; i++) &#123; if(GetHitKeyStateAll_Key[i]==1) stateKey[i]++; else stateKey[i]=0; &#125; return 0;&#125;int CheckStateKey(unsigned char Handle)&#123; return stateKey[Handle];&#125;//存储手柄输入状态的变量pad_t pad;//参数1和参数2中，较大者存入参数1void input_pad_or_key(int *p, int k)&#123; *p = *p&gt;k ? *p : k;&#125;//检查键盘和手柄双方的输入状态的函数void GetHitPadStateAll()&#123; int i,PadInput,mul=1; PadInput = GetJoypadInputState( DX_INPUT_PAD1 );//获得手柄的输入状态 for(i=0; i&lt;16; i++) &#123; if(PadInput &amp; mul) pad.key[i]++; else pad.key[i]=0; mul*=2; &#125; input_pad_or_key(&amp;pad.key[configpad.left] ,CheckStateKey(KEY_INPUT_LEFT )); input_pad_or_key(&amp;pad.key[configpad.up] ,CheckStateKey(KEY_INPUT_UP )); input_pad_or_key(&amp;pad.key[configpad.right] ,CheckStateKey(KEY_INPUT_RIGHT )); input_pad_or_key(&amp;pad.key[configpad.down] ,CheckStateKey(KEY_INPUT_DOWN )); input_pad_or_key(&amp;pad.key[configpad.shot] ,CheckStateKey(KEY_INPUT_Z )); input_pad_or_key(&amp;pad.key[configpad.bom] ,CheckStateKey(KEY_INPUT_X )); input_pad_or_key(&amp;pad.key[configpad.slow] ,CheckStateKey(KEY_INPUT_LSHIFT )); input_pad_or_key(&amp;pad.key[configpad.start] ,CheckStateKey(KEY_INPUT_ESCAPE )); input_pad_or_key(&amp;pad.key[configpad.change] ,CheckStateKey(KEY_INPUT_LCONTROL));&#125;//根据传进来的手柄按键的编号，返回其输入状态。返回-1代表出错int CheckStatePad(unsigned int Handle)&#123; if(0&lt;=Handle &amp;&amp; Handle&lt;PAD_MAX) &#123; return pad.key[Handle]; &#125; else &#123; printfDx(\"CheckStatePad传进来的参数不正确\\n\"); return -1; &#125;&#125; —————————————————————————————————————————————————————————————————————————————input_pad_or_key函数的传入参数写的比较长，如果用数列和指针的话可以省略和跳过一些，有余力的人可以自己尝试把它变短吧。—————————————————————————————————————————————————————————————————————————————–char.cpp 的改动– #include “../include/GV.h” void calc_ch(){ ch.cnt++; ch.img=(ch.cnt%24)/6; if(CheckStatePad(configpad.left)&gt;0)//左键按下的话 ch.x-=3;//坐标往左移 if(CheckStatePad(configpad.right)&gt;0)//右键按下的话 ch.x+=3;//坐标向右移}—————————————————————————————————————————————————————————————————————————————CheckStatePad函数的用法就像上面这样。根据设定好的键位，比如左键的编号 configpad.left 输入进去，这个就被传入到CheckStatePad函数里。输入的计数状态就会返回，如果不是0就说明这个键正在被按下。然后，我们把这次增加的函数，加到头文件里面吧。—————————————————————————————————————————————————————————————————————————————–function.h 里加入如下代码– GLOBAL void GetHitPadStateAll();GLOBAL int CheckStatePad(unsigned int Handle);—————————————————————————————————————————————————————————————————————————————这次main 文件的改动，只有下面GetHitPadStateAll();的这一行。————————————————————————————————————————————————————————————————————————————— 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//--main.cpp改动--#define GLOBAL_INSTANCE#include \"../include/GV.h\"//主循环里必须做的三大处理int ProcessLoop()&#123; if(ProcessMessage()!=0) return -1 ; //Process处理出错的话，返回-1 if(ClearDrawScreen()!=0) return -1; //画面清理出错的话，返回-1 GetHitKeyStateAll_2(); //当前键盘输入处理 GetHitPadStateAll(); //当前手柄输入处理 （就加了这一行） return 0;&#125;int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)&#123; ChangeWindowMode(TRUE); //窗口模式 if(DxLib_Init() == -1 || SetDrawScreen( DX_SCREEN_BACK )!=0) return -1; //初始化和设置双缓冲模式 while(ProcessLoop()==0) //主循环 &#123; switch(func_state) &#123; case 0: load(); //载入数据 first_ini(); //第一次初始化 func_state=100; break; case 100: calc_ch(); //计算角色的使用图片（这句上一章就加了啊） graph_main(); //主绘画函数 break; default: printfDx(\"未知的func_state\\n\"); break; &#125; if(CheckStateKey(KEY_INPUT_ESCAPE)==1) break; //按下ESC的话，break ScreenFlip(); //交换双缓冲画面 &#125; DxLib_End(); //DxLib中止 return 0;&#125; —————————————————————————————————————————————————————————————————————————————运行结果http://dixq.net/rp/swf/08.swf—————————————————————————————————————————————————————————————————————————————连续按手柄的左右键，然后按键盘方向键的左右键，任务像动画那样左右可以移动的话，就成功了。 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第7章、把面板表示出来吧","date":"2013-11-23T16:24:00.000Z","path":"2013/11/24/【四圣龙神录的编程教室】第7章、把面板表示出来吧/","text":"原文地址：http://dixq.net/rp/7.html 一直都是自机在左上角这边很不好玩啊，我们把最基本的框架显示出来看看吧。首先在GV.h 里把存储面板用的画像表示出来吧。 —————————————————————————————————————————————————————————————————————————————–GV.h里添加如下语句– GLOBAL int img_board[40]; —————————————————————————————————————————————————————————————————————————————顺便一提，作为下一章的准备，我们先把初始化函数准备好吧。然后，我们先定义下自机运动的范围的区域的显示吧。FIELD_MAX_X, ～Y 是各种各样的角色的运动领域的大小。FIELD_X, ～Y 是那个领域的左上角的坐标。下面表示的数值表示是以（32,16）坐标开始，横384，竖448的大小作为角色移动的领域。—————————————————————————————————————————————————————————————————————————————–define.h改动– #include “struct.h” #define FIELD_MAX_X 384 #define FIELD_MAX_Y 448 #define FIELD_X 32 #define FIELD_Y 16—————————————————————————————————————————————————————————————————————————————表示角色的图像在calc_ch里计算。通过count计数的增加，每24作为一个周期。在其中，4张图片循环调用。正如在data文件里所看到的角色图像那样，角色用4张图片组成一个动作，下面的式子，就是循环计算角色的图片编号。—————————————————————————————————————————————————————————————————————————————–char.cpp改动– #include “../include/GV.h” void calc_ch(){ ch.cnt++; ch.img=(ch.cnt%24)/6;}—————————————————————————————————————————————————————————————————————————————要在MainLoop里面调用的函数，声明的时候要写在function.h 里面呢。—————————————————————————————————————————————————————————————————————————————–function.h里加上如下代码– GLOBAL void calc_ch();—————————————————————————————————————————————————————————————————————————————load.cpp 里，要读取面板的图片数据。保存的数组序号是分散的这么几个数，其实没什么特殊的含义，以后图片要更换的话是件很容易的事。 用从0开始的连续的序号的话也没什么关系的。—————————————————————————————————————————————————————————————————————————————–load.cpp 改动– #include “../include/GV.h” void load(){ img_board[10] = LoadGraph(“../dat/img/board/10.png”); img_board[11] = LoadGraph(“../dat/img/board/11.png”); img_board[12] = LoadGraph(“../dat/img/board/12.png”); img_board[20] = LoadGraph(“../dat/img/board/20.png”); LoadDivGraph( “../dat/img/char/0.png” , 12 , 4 , 3 , 73 , 73 , img_ch[0] ) ;}—————————————————————————————————————————————————————————————————————————————设定角色的初始坐标。—————————————————————————————————————————————————————————————————————————————–ini.cpp 改动– #include “../include/GV.h” //最开始坐标的初始化void first_ini(){ ch.x=FIELD_MAX_X/2; ch.y=FIELD_MAX_Y*3/4;} —————————————————————————————————————————————————————————————————————————————显示面板的函数 ，graph_board， 先准备好。————————————————————————————————————————————————————————————————————————————— 12345678910111213141516171819//--graph.cpp 的改动--#include \"../include/GV.h\"void graph_ch()&#123; DrawRotaGraphF(ch.x+FIELD_X,ch.y+FIELD_Y,1.0f,0.0f,img_ch[0][ch.img],TRUE);&#125;void graph_board()&#123; DrawGraph( 0, 0,img_board[10],FALSE); DrawGraph( 0, 16,img_board[11],FALSE); DrawGraph( 0,464,img_board[12],FALSE); DrawGraph(416, 0,img_board[20],FALSE);&#125;void graph_main()&#123; graph_ch(); graph_board();&#125; —————————————————————————————————————————————————————————————————————————————在main 文件里，主循环里的 case 100 里面加上 calc_ch; 就这点改动。 (原文是加上 first_init() ，估计有误）————————————————————————————————————————————————————————————————————————————— 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//--main.cpp改动--#define GLOBAL_INSTANCE#include \"../include/GV.h\"//主循环里必须做的三大处理int ProcessLoop()&#123; if(ProcessMessage()!=0) return -1 ; //Process处理出错的话，返回-1 if(ClearDrawScreen()!=0) return -1; //画面清理出错的话，返回-1 GetHitKeyStateAll_2();//当前键盘输入的处理 return 0;&#125;int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)&#123; ChangeWindowMode(TRUE); //窗口模式 if(DxLib_Init() == -1 || SetDrawScreen( DX_SCREEN_BACK )!=0) return -1; //初始化和设置双缓冲模式 while(ProcessLoop()==0) //主循环 &#123; switch(func_state) &#123; case 0: load(); //载入数据 first_ini(); //第一次初始化 func_state=100; break; case 100: calc_ch(); graph_main();//主绘画函数 break; default: printfDx(\"未知的func_state\\n\"); break; &#125; if(CheckStateKey(KEY_INPUT_ESCAPE)==1) break; //按下ESC的话，break ScreenFlip(); //交换双缓冲画面 &#125; DxLib_End();//DxLib中止 return 0;&#125; ————————————————————————————————————————————————————————————————————————————运行结果： 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第6章、定制一下主循环里的调用函数吧","date":"2013-11-23T12:41:00.000Z","path":"2013/11/23/【四圣龙神录的编程教室】第6章、定制一下主循环里的调用函数吧/","text":"原文地址：http://dixq.net/rp/6.html MainLoop里调用的函数，会把当前的各种各样的状态返回，对吧。也就是说，我们有必要定制一下MainLoop里面调用的函数。因此，我们准备一个func_state变量，把表示状态的值存进去，然后根据不同的条件进行分支的操作吧。我们要把func_state 定义成全局变量，所以，首先加到 GV.h 里面。 ————————————————————————————————————————————————————————————————————————————–GV.h 里加上下面的内容–GLOBAL int func_state;————————————————————————————————————————————————————————————————————————————为了给下一节做准备，我们先把初始化函数给准备好吧。—————————————————————————————————————————————————————————————————————————————–ini.cpp里加上下面这段– void first_ini(){ }—————————————————————————————————————————————————————————————————————————————给mainloop里要调用的函数需要先声明呢，而声明得写在function.h里面—————————————————————————————————————————————————————————————————————————————–function.h里写下如下语句– GLOBAL void first_ini();—————————————————————————————————————————————————————————————————————————————在mainLoop里，用准备好了的func_state 来进行条件的分支判断。————————————————————————————————————————————————————————————————————————————— 123456789101112131415161718192021222324252627282930313233343536373839404142434445//--main.cpp改动--#define GLOBAL_INSTANCE#include \"../include/GV.h\"//主循环里必须做的三大处理int ProcessLoop()&#123; if(ProcessMessage()!=0) return -1 ;//Process处理出错的话，返回-1 if(ClearDrawScreen()!=0) return -1; //画面清理出错的话，返回-1 GetHitKeyStateAll_2(); //获取现在的键盘输入情况 return 0;&#125;int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)&#123; ChangeWindowMode(TRUE); //窗口模式 if(DxLib_Init() == -1 || SetDrawScreen( DX_SCREEN_BACK )!=0) return -1; //初始化和设置双缓冲模式 while(ProcessLoop()==0) //主循环 &#123; switch(func_state) &#123; case 0: load(); //载入数据 first_ini();//第一次初始化 func_state=100; break; case 100: graph_main();//主绘画函数 break; default: printfDx(\"未知的func_state\\n\"); break; &#125; if(CheckStateKey(KEY_INPUT_ESCAPE)==1) break; //按下ESC的话，break ScreenFlip(); //交换双缓冲画面 &#125; DxLib_End();//DxLib中止 return 0;&#125; —————————————————————————————————————————————————————————————————————————————和第四章的执行结果一样。可以和以前一样运行起来的话，就算成功了。 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第5章、研究下声明的方法吧","date":"2013-11-19T17:05:00.000Z","path":"2013/11/20/【四圣龙神录的编程教室】第5章、研究下声明的方法吧/","text":"原文地址：http://dixq.net/rp/5.html 在上一节，main文件已经乱作一团，这有个变量定义，那又有个extern什么的，已经有点看不懂了。于是，我们来研究一下变量定义和extern 声明的方法吧。等等，在这先对上一章做一下概括吧。・（这次设计的场景）全局变量，定义在主文件 main.cpp 里面了・ 从其他的文件引用这里的全局变量的时候，在其他文件里要用extern声明。就是酱紫呢。但是，在主文件里定义，然后在其他文件里使用extern调用同样的变量时，感觉是个效率比较低的方法。那么，我们在所有文件里都调用同一个头文件，在这个头文件里面，根据在哪里被调用写个条件分支，然后给出适当的声明。如果这样做的话，效率就比较高了。稍微看一下下面这段程序吧。 —————————————————————————————————————————————————————— #ifdef GLOBAL_INSTANCE #define GLOBAL #else #define GLOBAL extern #endif GLOBAL int img;————————————————————————————————————————————————————————（以下这段翻译里的“调用”，指的是GLOBAL int img; 这行代码被预处理后实际变成的样子。也就是说，这个“调用”指的是预处理操作）这段代码的含义是，如果定义了GLOBAL_INSTANCE的话，GLOBAL就被替换成空白如果没有定义GLOBAL_INSTANCE的话，GLOBAL就被替换成extern然后，我们这样写GLOBAL int img;会怎么样呢？是的，这样的话，用和不用extern， 就被区分开了。因为从main.cpp调用的时候，必须是定义，所以不加extern 。也就是说，定义了GLOBAL_INSTANCE之后，调用就很方便了。（自动去掉GLOBAL）另一方面，从其他文件调用这个img全局变量，我们得加上extern。也就是说，不定义GLOBAL_INSTANCE，也啥都不用写，很方便。（自动会把GLOBAL变成extern）这里我们看一下main 文件的最上面吧。那里写着 #define GLOBAL_INSTANCE #include “../include/GV.h”这里定义了GLOBAL_INSTANCE，调用的时候，就是对变量的定义。其他文件没有定义这个，调用的时候，就会加上extern.这样，就实现了从其他文件来调用main里定义的全局变量的方式。 这样的话还有一点。已经实现的函数被其他文件调用的时候，同样也需要在main文件里声明一次。声明了extern的话，在程序实现的地方和调用的地方都有好处。在main文件里只要用extern声明了，不管在哪里实现的，可以调用到。（此处翻译有点不够到位，求指正）然后，在根据不同的条件，在 GV.h 的引入 function.h也用上述同样的GLOBAL来声明看看吧。其实，看了就应该很容易明白了，像下面这样添加上去吧。———————————————————————————————————————————————————————— 123456789101112131415//--function.h改动--//graph.cpp //描画 main GLOBAL void graph_main();//key.cpp //现在的键位输入状态 GLOBAL int GetHitKeyStateAll_2(); //根据键的序号，返回输入的状态 GLOBAL int CheckStateKey(unsigned char Handle);//laod.cpp //数据载入 GLOBAL void load(); ———————————————————————————————————————————————————————— ———————————————————————————————————————————————————————— 123456789101112131415161718//--GV.h改动--#include \"../../../include/DxLib.h\"#include \"define.h\"#ifdef GLOBAL_INSTANCE#define GLOBAL#else#define GLOBAL extern #endif#include \"function.h\" //函数声明//图片变量声明GLOBAL int img_ch[2][12]; //自机的图片9张 X2(变身用)//构造体变量声明GLOBAL ch_t ch; //构造体数据声明 ———————————————————————————————————————————————————————— 然后在「main.cpp」「graph.cpp」「load.cpp」的在这些变量的定义部分，把extern 都去掉。编译一下，如果没有错误，结果和第四节一样的话，就OK了。以后，添加全局变量，就往GV.h 里面添加，需要在 main 文件调用，在其他文件声明的方法，就往 function.h 里面添加吧。 （注：看得出来，这章主要是总结集中了全局变量和方法的声明和调用的方法。熟悉C/C++的应该很容易懂吧）（我是还没怎么看明白，所以有些地方翻译的没能很好表达清楚意思。等我把第四章和第五章的程序改动读一遍，再来这修改一下吧）研究了一下项目预处理之后的文件，大概推断出了#include 和上面 #ifnef 这些的作用了。首先我们理一下这一章和上一章的变动。原先，是在main 里面定义了两个全局变量。然后用extern 声明需要写在其他文件里面的函数。同时，其他文件要调用main里定义的全局变量也要加extern。弄得很乱。（补充一点关于extern，其实main里调用其他函数时写的声明，可以去掉extern的。但其他文件用extern声明main里面定义的，这个extern不能去掉，不然就重复定义了）修改后，GV.h 加上ifndef 判断，然后，函数声明都加上GLOBAL放到 function.h 里面，include 到GV.h中。全局变量也加上GLOBAL，在GV.h里声明。相当于，所有函数和全局变量，都加上GLOBAL声明，放在GV.h里面。其他文件包含GV.h了，就可以去掉对 全局变量单独写引用声明了。然后，由于main.cpp定义了GLOBAL_INSTANCE ， 预处理的时候，GV.h全部包含进来后，会去掉extern。这样，变量就变成定义，函数去掉extern也还是声明。其他文件没有定义GLOBAL_INSTANCE ，预处理GV.h全部包含进来后，会保留extern。这样就 声明了定义在别处的 全局变量和函数。 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第4章、画个自机形象看看吧","date":"2013-11-17T13:44:00.000Z","path":"2013/11/17/【四圣龙神录的编程教室】第4章、画个自机形象看看吧/","text":"原文地址：http://dixq.net/rp/4.html 接下来，画个人自机试试吧。为此，我们首先得定义个结构体，把自机所需的变量都定义好。自机的结构体，定义成如下这样。 ——————————————————————————————————————————————————————————————————————–struct.h改动– 123456789101112131415//自机相关的结构体typedef struct&#123; int flag; //标志 int cnt; //计数 int power; //火力 int point; //点数 int score; //得分 int num; //残机数 int mutekicnt; //无敌状态的计数 int shot_mode;//射击模式 int money; //金钱 int img; //图像 int slow; //是否为慢速模式 double x,y; //坐标&#125;ch_t; ——————————————————————————————————————————————————————————————————————把这个构造体的定义，写在 struct.h 文件里面。里面定义的东西有点多，但无需全部记住。自机有着各种各样的数据呢，火力啊，得分啊，目前的射击模式啊。。。总之，我们就先把这些都准备好。现在我们只关心坐标，反正我们先记住，自机的构造体里面有double 型的x 和 y 的变量。 接下来，我们需要读取自机的图片了。我们用img_ch这个变量，来表示图片的句柄（Handler）自机的图片，是12张一套的。因为龙神录里面有变身，所以这里需要两套图片。int img_ch[2][12];像这样，定义好变量后，就可以使用了。把变量在main 文件里面定义好之后，在下面的load.cpp 用extern 声明一下，然后就可以使用了。————————————————————————————————————————————————————————————————————–load.cpp改动– 123456789#include \"../include/GV.h\"extern int img_ch[2][12];void load()&#123; LoadDivGraph( \"../dat/img/char/0.png\" , 12 , 4 , 3 , 73 , 73 , img_ch[0] ) ;&#125; —————————————————————————————————————————————————————————————————————在上面的路径下，确认图片是否存在。上面的函数读入的含义是，总共是12张图片，横着4张，竖着3张，长宽为 73-73 像素的，存放到 img_ch[0] 里面去。如果不理解的话，去官方主页的参考手册页面（reference page），确认下这个函数的使用方法吧。那么，画图的函数 graph.cpp 也需要改动了。再声明一个 graph_main 函数，方便在 main 文件里整个调用。——————————————————————————————————————————————————————————————————————–graph.cpp改动– 1234567891011121314#include \"../include/GV.h\"extern ch_t ch;extern int img_ch[2][12];void graph_ch()&#123; DrawRotaGraphF(ch.x,ch.y,1.0f,0.0f,img_ch[0][ch.img],TRUE);&#125;void graph_main()&#123; graph_ch();&#125; ——————————————————————————————————————————————————————————————————————然后，是最重要的main.cpp文件了。——————————————————————————————————————————————————————————————–main.cpp改动– 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#define GLOBAL_INSTANCE #include \"../include/GV.h\"//现在的按键输入的处理extern int GetHitKeyStateAll_2();//根据收到的按键序号，返回这个键现在的输入状态extern int CheckStateKey(unsigned char Handle);//数据的载入extern void load();//主绘制函数extern void graph_main();int img_ch[2][12]; //自机的图片12张 X2(变身用)ch_t ch; //自机的结构体//主循环里必做的三大操作int ProcessLoop()&#123; if(ProcessMessage()!=0) return -1; //Process 处理出错的话，返回-1 if(ClearDrawScreen()!=0) return -1; //清理画面出错的话，返回-1 GetHitKeyStateAll_2(); //对现在的按键输入进行处理 return 0;&#125;int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)&#123; ChangeWindowMode(TRUE);//窗口模式 if(DxLib_Init() == -1 || SetDrawScreen( DX_SCREEN_BACK )!=0) return -1; /初始化和设置双缓冲 load();//载入数据 while(ProcessLoop()==0)&#123; //主循环 graph_main(); //绘制函数 if(CheckStateKey(KEY_INPUT_ESCAPE)==1) break; //输入ESC的话，break ScreenFlip(); //交换双缓冲画面 &#125; DxLib_End();//DxLib终止 return 0;&#125; ——————————————————————————————————————————————————————————————运行结果： 显示像上面这样的话，就完成了。在左边可以看到一点点的自机。哎呀，不要啊。怎么 main函数变得这么难读了 啊~~不过不要紧，我们在下一章里把它整理的漂亮一些吧。 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第3章、使用全局变量看看吧","date":"2013-11-15T17:35:00.000Z","path":"2013/11/16/【四圣龙神录的编程教室】第3章、使用全局变量看看吧/","text":"原文地址：http://dixq.net/rp/3.html 那个叫做 GetHitKeyStateAll_2 的按键输入处理函数 ，从刚刚的示例代码里，复制到这里来了。像刚刚那样，key的处理函数必须是全局函数，但全局变量在哪里都可能被修改，所以尽量少用比较好。虽然还是用了全局变量，让我们来试试尽量减少bug发生率的方法。 ————————————————————————————————————————————————————————————– key.cpp的改动 – 12345678910111213141516171819#include \"../include/GV.h\"unsigned int stateKey[256];int GetHitKeyStateAll_2()&#123; char GetHitKeyStateAll_Key[256]; GetHitKeyStateAll( GetHitKeyStateAll_Key ); for(int i=0;i&lt;256;i++)&#123; if(GetHitKeyStateAll_Key[i]==1) stateKey[i]++; else stateKey[i]=0; &#125; return 0;&#125;int CheckStateKey(unsigned char Handle)&#123; return stateKey[Handle];&#125; ——————————————————————————————————————————————————————————————— 像上面这样，main 文件 和 key 文件分开写。现在，我们需要调用 ESC 键按下的状态 Key[KEY_INPUT_ESCAPE]但是 ，有这个Key 的 stateKey 为了不让其他地方直接访问到，用 CheckStateKey 函数来返回 那个键的序号。这样，Key 的值被不小心修改的可能性就降低了。现在，就用上面的封装了的 CheckStateKey 函数来传递Key的序号，来检查一下 Key 的输入状态吧。另外，其他的文件如果要访问封装的变量或者函数，需要加上 extern 来声明。 // 现在 处理 按键输入extern int GetHitKeyStateAll_2();// 返回 接收到的 Key 的序号的输入状态extern int CheckStateKey(unsigned char Handle); 现在，可以在main.cpp用这种写法，在main 文件内访问key文件内定义的函数了。除此之外，上一节写的 MainLoop 每次都会写到的，就把它整理到一个 叫ProcessLoop 的函数里面去了。这不会改变程序的运行。恩，我们来看看修改后的main 文件吧。————————————————————————————————————————————————————————————————–main.cpp的改动— 12345678910111213141516171819202122232425262728293031#define GLOBAL_INSTANCE #include \"../include/GV.h\"//对现在的按键输入进行处理extern int GetHitKeyStateAll_2();//根据收到的键的序号，返回现在的输入状态extern int CheckStateKey(unsigned char Handle);//主循环里，一定要进行的三大处理int ProcessLoop()&#123; if(ProcessMessage()!=0) return -1; //Process 处理出错的话，返回-1 if(ClearDrawScreen()!=0) return -1; //清理画面出错的话，返回-1 GetHitKeyStateAll_2(); //对现在的按键输入进行处理 return 0;&#125;int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)&#123; ChangeWindowMode(TRUE);//窗口模式 if(DxLib_Init() == -1 || SetDrawScreen( DX_SCREEN_BACK )!=0) return -1; //初始化和设置双缓冲 while(ProcessLoop()==0)&#123; //主循环 if(CheckStateKey(KEY_INPUT_ESCAPE)==1) break; //输入ESC的话，退出主循环 ScreenFlip();//交换双缓冲画面 &#125; DxLib_End();//DxLib终止 return 0;&#125; ———————————————————————————————————————————————————————————— 按下ESC就退出的话，就完成了。 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第2章、首先运行下看看吧","date":"2013-11-15T15:15:00.000Z","path":"2013/11/15/【四圣龙神录的编程教室】第2章、首先运行下看看吧/","text":"原文地址：http://dixq.net/rp/2.html 首先运行一下看看吧。项目的 main.cpp 就是 游戏编程教室里有说到过的 “ 每次都要写的程序的基本框架” ，然后点击编译，运行一下这个程序。 —————————————————————————————————————————————————————————————————— ————main.cpp 的改动—————— 1234567891011121314151617181920212223242526272829303132333435#define GLOBAL_INSTANCE #include \"../include/GV.h\"int Key[256];int GetHitKeyStateAll_2(int GetHitKeyStateAll_InputKey[])&#123; char GetHitKeyStateAll_Key[256]; GetHitKeyStateAll( GetHitKeyStateAll_Key ); for(int i=0;i&lt;256;i++)&#123; if(GetHitKeyStateAll_Key[i]==1) GetHitKeyStateAll_InputKey[i]++; else GetHitKeyStateAll_InputKey[i]=0; &#125; return 0;&#125;int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,LPSTR lpCmdLine, int nCmdShow )&#123; ChangeWindowMode(TRUE);//ウィンドウモード if(DxLib_Init() == -1 || SetDrawScreen( DX_SCREEN_BACK )!=0) return -1;//初始化和设置双缓冲屏幕 while(ProcessMessage()==0 &amp;&amp; ClearDrawScreen()==0 &amp;&amp; GetHitKeyStateAll_2(Key)==0 &amp;&amp; Key[KEY_INPUT_ESCAPE]==0)&#123; //↑消息処理 ↑清除屏幕 ↑保存按键输入 ↑没有按ESC键 //这里！！ ScreenFlip(); &#125; DxLib_End(); return 0;&#125; 注：这里为初学者和像我一样不愿研究代码的人做一点简单的代码说明。主要是保存按键输入的函数。首先主函数里调用了上面的函数，传入的参数是定义的全局变量数组Key [256]在上面的函数里，定义了个char 数组，然后传给系统函数GetHitKeyStateAll_Key，获得按键状态。然后遍历一遍char数组，转存到int 数组，把对应的 按键在int数组里 ++，没有按就清零。（完毕，虽然感觉这两个数组来转存有点绕的感觉） 好了，窗口就调出来了，按ESC的话，就会退出。到此为止，你如果进行很顺利的话，准备工作就完毕了 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"东方","slug":"东方","permalink":"http://yoursite.com/tags/东方/"},{"name":"STG","slug":"STG","permalink":"http://yoursite.com/tags/STG/"},{"name":"射击游戏","slug":"射击游戏","permalink":"http://yoursite.com/tags/射击游戏/"}]},{"title":"【四圣龙神录的编程教室】第1章、准备项目的素材","date":"2013-11-13T16:57:00.000Z","path":"2013/11/14/【四圣龙神录的编程教室】第1章、准备项目的素材/","text":"原文地址：http://dixq.net/rp/1.html 龙神录的编程教室，是使用VisualStudio 2005 或者 2008 作为工具来讲解的。下面的项目，是带上了素材一起打包进去了的。 整个项目一起打包下载 文件夹的组成，大概是长这个样子 上面图片里虽然写着第一章，但这里会加很多东西进去的。 以后的章节下载的文件夹，请像这样添加进去。 每个章节里都有一个 RyuJin.sln ，打开它。dat 文件夹，里面有图像，音乐，音效等等这些放在一起数据。mydat 文件夹，里面有自己的头文件，源代码，PhotoShop的数据等，自己使用的数据include 文件夹，是存放DxLib 的文件夹。打开最上面的 RyuJin.sln 。这些，就是项目所必须的最基本的构成 就像你在解决方案资源管理器所看到的这种方式，文件就是这样的结构。 我擦，怎么这么多文件啊！请不用担心。我们还什么都没写呢。我们还没有在任何文件里写过一行，所以对这些东西不需要任何了解。要说，为什么这里只有Hard Mode的话，首先为了要做最复杂的弹幕，我们会选用简单的方法，这样做起来会比较容易。为了要制作最复杂的弹幕，我们往往要先准备减少子弹的数量和用比较简单的轨道，但反过来说，制作了简单的弹幕然后变成复杂的弹幕的话，要增加多少子弹，我们并不知道，为了增加子弹，可能经常会破坏掉整体的平衡，所以我们直接一开始就制作很复杂的弹幕吧。这一章，只要理解到“项目里面还有这样的文件在啊” ，这样的程度就足够了。如果对文件的构成产生兴趣了，那下面对各种各样的文件进行简单说明，可以参考一下。 以上面图片里面的顺序：boss_shotH.cpp boss 弹幕的文件（hard）boss_shot.cpp 控制boss弹幕的文件enemy.cpp 控制杂鱼移动的文件enemy_act_pattern.cpp 控制杂鱼移动模式的文件graph.cpp 绘制画面相关的文件graph_back.cpp 绘制背景相关的文件shotH.cpp 杂鱼的射击的文件（Hard）cshot.cpp 自己射击的文件shot.cpp 控制杂鱼射击的文件char.cpp 控制自机的文件fps.cpp 控制fps的文件ini.cpp 初始化的文件key.cpp 控制键位的文件load.cpp 图片和音乐加载的文件main.cpp Main 函数music.cpp 音乐的控制文件out.cpp 碰撞检测的文件 define.h 写定义用的的头文件function.h 外部声明用的头文件GV.h 为了引用全局变量的头文件struct.h 定义构造体的头文件 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】第0章  开始","date":"2013-11-13T15:07:00.000Z","path":"2013/11/13/【四圣龙神录的编程教室】第0章  开始/","text":"原文地址：http://dixq.net/rp/0.html 龙神录的编程教室，是以通俗易懂的方式，来讲解基本的射击游戏作为目标的地方。如果把这里的每个章节，都认真学习了之后，你就可以制作出像龙神录这样的射击游戏了。 如果对龙神录还不熟悉，请点击这里**→四聖龍神録的主页へ **四圣龙神录，是使用了包含DirectX库的DxLib库来制作的。这里以知道基本的DxLib的使用方法，知道基本C语言的知识作为前提，尽量以对初学者没有阻碍，极力避免难懂的书写方法，来进行讲解和介绍。但是，有一件事，要事先说明一下。这个馆 ，没有游戏编程的模型设计等相关方面的介绍。效率性，封装性，还有通用性和可扩展性都不会考虑，总之不采用复杂的程序实现，才是这里的目的。因此，像本馆的这种将大多数变量作为全局变量使用的设计方法，在代码量很大的项目上是不合适的方法！关于效率的设计方法，下次在其他的游戏编程馆里再介绍吧。 这里需要具备的知识，是最低限度的C语言的知识。・构造体・排列・自己编写函数・预处理器等等这些知识就足够了。如果遇到奇怪的知识点，去入门的网站重新复习一下就好了。关于DxLib的基本使用方法，在游戏编程馆里能再重新复习一下就好了。 有什么不明白的地方，不用顾虑，直接去提问版去质问（提问）就好了。接下来，龙神录的编程教室的讲座，可以开始了。 上面分别是： 龙神录编程教室的主页。作者的主页。C语言什么都可以问的提问版。 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"东方","slug":"东方","permalink":"http://yoursite.com/tags/东方/"},{"name":"STG","slug":"STG","permalink":"http://yoursite.com/tags/STG/"}]},{"title":"【四圣龙神录的编程教室】——使用规则","date":"2013-11-12T17:47:00.000Z","path":"2013/11/13/【四圣龙神录的编程教室】使用规则/","text":"原文网址：http://dixq.net/rp/kiyaku.html 使用规则 2007 12/15 更新※注意※最近有很多毕业设计，还有其他地方就直接用了这里的内容，所以这里制定以下规则，希望大家遵守。（好像是这个意思吧？翻译） 首先，对于不知道“东方”的人来说，这个游戏的系统，是仿照东方Project 系统的，请注意一下。东方Project 系列，是十分优秀的游戏，如果有兴趣的话，请一定要去体验一下东方系列的游戏（主页有体验版的下载）——————————————————————————————————————————————————————————这里是，学习STG游戏的编程，然后学会制作的一个网站。当然，也是表达了对东方系列和弹幕游戏的热爱的一个网站。看了这个网站后，像四圣龙神录这样的游戏，就能够制作出来了。程序可以用常用的函数，按自己的喜好搭建构造出来。但是，如果参考这里给出的程序，进行发布，贩卖，以及向教育机构和企业提供的话，请向这里通知一下。图片除了龙的图片以外，其他的允许进行二次使用。但是，这是以东方系列为模型的，请了解后再使用。音乐和音效，不允许进行二次使用。（可以自己创作，音效可以去 The Matchmakers ，音乐可以去 煉獄庭園 这些地方找一下 ）● 如果是一个人制作出来，自娱自乐的→这样的话，随便怎么玩都没关系● 用这里的项目的代码，制作出游戏，然后去免费发布→请记得在主页和手册等容易看到的地方，介绍一下四圣龙神录，拜托了●用这里的项目的代码，制作出游戏，然后去收费发布→事先和这里打过招呼，通过了的话才行。●用这里的项目的代码，去制作毕业设计，或者向教育机构和公司企业提交作品→使用的时候，请参考 ※1 ，请先向这里申请允许，和我们联系。●向动画网站进行动画的投稿→说明了使用自本网站的代码（比如贴上URL）的话，随便怎么投稿都是可以的。 ※关于管理员给出这些规则的考虑※以上海爱丽丝幻乐团做的游戏为基础的我做出这样的规则，确实有点奇怪。我也是喜欢二次创作的人，也不想订立太详细的使用规则。让你们能随便用这里的程序。偶尔 有“去馆里参考了一下，做出了一个游戏哦！来一起玩吧” 这样的消息反馈过来，我也很高兴有什么好东西制作出来的话，一定要让我玩一下哦。 不过，直接就这么 复制一下，然后就当做毕业设计什么的，我还是希望觉得尽量不要这样做的。程序的内容理解之后，不管要做什么样的设计，要是有不明白的，都可以来馆里来问的。 要给出参考或者引用资料的时候，给出下面的信息就行了。制作人： Dixq社团名：RemicalSoft网站名：龍神録プログラミングの館 （龙神录的编程馆） 这个游戏使用的游戏库是 DxLib著作权表示：DX Library Copyright (C) 2001-2006 Takumi Yamada.DxLib的著作权相关的详细信息，请去它的主页看吧。http://homepage2.nifty.com/natupaji/DxLib/dxlicense.html 联系方式→ dixqhp@gmail.com ※1作为毕设，或者当做作品，向教育机构和企业提交的时候，请先联系我一下。联系的时候，请在内容里写上要提交到哪里，以及您的名字，谢谢。 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录的编程教室】","date":"2013-11-10T16:38:00.000Z","path":"2013/11/11/【四圣龙神录的编程教室】/","text":"原文地址：http://dixq.net/rp/ 龙神录的 programming 馆龙神录的编程教室，是为了让谁都可以制作龙神录（仿东方的STG）的一个解说教学的地方。这里没有复杂的语句，使用初学者也能看懂的语言来介绍。只要有C语言的基本知识，和DxLib 的知识，谁都可以制作龙神录的！游戏编程教室的DxLib 使用熟练后，现在我们就来制作真正的游戏吧。接下来，是 游戏的介绍画面。 下载四聖龍神録Plus来试试看玩一下吧。全部章节的 项目文件，一次性打包下载，在这里—— こちら有啥错误，错别字或者各章有什么错漏的其他各种问题，就到论坛给作者反应吧。（在本博客里，由于本人水平问题，可能会出现翻译不准确和错误，真是对不起了啊。。。） 别再一个人烦恼有新的想法，但不知道改想做新的弹幕，但不知道怎么做或者，连编程都还不大明白是怎么回事有这些问题，都去提问版提问吧，有烦恼，就去问 → 質問掲示板 章节 内容 使用规则0开始1项目和素材的准备2首先，运行一下试试3使用 global 参数 看看吧 （global 的日语蛋疼死我了）4来画个人物看看吧5来声明一个方法吧6来操作 Main Loop里调用的函数吧7显示一下界面吧，（计分板等等）8设置一下键位的对应吧 （KeyConfig ）9我们来编写一下角色的移动吧10加入敌人的显示吧11使用Excel 制作敌机出现的数据表吧12制作一个大量敌机的运动模式吧13让敌人有射击的功能吧。14尝试制作各种各样的弹幕吧15做个喵的弹幕吧，喵16尝试制作一下建御名方神的弹幕吧 （ミシャグジ様 搜索半天，最后只在谷歌里找个大概的意思啊）17 尝试制作自机的发射子弹吧18给自己发射的子弹打中的判定吧19给敌机加上被消灭的效果吧20我们来画一下背景吧21加上自机被打中的判定，和无敌时间的处理吧22加上Bomb （炸弹）吧23给炸弹（符卡）加上 决死吧 （就是被打中的瞬间放出炸弹）24我们再做个boss出来25boss 被打中的判定26给boss 加点特效吧27 弹幕【SilentSerenade】的制作 （静默的夜曲）28弹幕【Perfect Freeze】的制作 （完美冻结）（⑨的符卡吗？）29弹幕【恋的迷路】的制作30弹幕【小青蛙不输风雨】的制作 （青蛙子的弹幕）31早苗风的弹幕的制作 （早苗教你画星星的弹幕）32 之后就一个人都没有了吗？ 类型的弹幕的制作 1 (二小姐的弹幕）33 之后就一个人都没有了吗？ 类型的弹幕的制作 234激光的弹幕制作35弹幕【反魂蝶八分咲】的制作36弹幕【深弹幕结界 - 梦幻泡影】的制作 (「深弾幕結界」モドキ)37消除代码段里的警告吧38关卡名称的表示39道具的显示40添加道具的获得处理逻辑番外一章可以实际做一个小游戏了41得分表的制作42闪光效果的制作番外二章加入音效的弹幕43加入准确的FPS显示44加入方便debug的函数45道中Boss 和最终Boss46描绘函数的引用参数修改一下47我们可以做一个 1面来看看啦48加上BGM49加上自机的子弹类型选择50加上子弹的跟踪功能 （ホーミング， 是翻译成追踪不？ 还是Homing ？） 到此为止，游戏的框架就已经完成了下面的，是一些扩展的功能的介绍 番外三章弹幕【正直者之死】的制作51来做一个汉字弹幕的制作工具吧 152来做一个汉字弹幕的制作工具吧 253我们来做汉字弹幕吧54做一个 图像–&gt; 弹幕的工具吧 155 做一个 图像–&gt; 弹幕的工具吧 256我们做一个图像弹幕吧57我们做个3D背景吧 158我们做个3D背景吧 259我们做个3D背景吧 360在游戏里使用3D背景吧 后面的翻译不动了，得睡了。2点了，今天都困，明天还要上班的啊。。。 zzzzz = = 特定の章のコード変更点を確認する方法 ※ 更新履歴 ※ 6/05 17章を修正(追加項目漏れ・パスの間違い) 6/05 22章を修正(追加項目漏れ) 5/25 レーザー情報の初期化漏れを修正 (enter_boss関数内に初期化追加) 4/12 50章 - 改 - を追加。敵HP表示をDrawModiGraphによる描画に変更 4/ 5 13章のコード追加分説明不足部を追加(13章修正) 2/17 60章追加 2/ 6 59章追加 龍神録C++版オープンソース化計画は第三回あたりで中断中・・。第一回 (2011/10/09)第二回 (2011/10/17)第三回 (2011/10/24) 公開しているソースコードは好きにお使い下さい。（本館の利用規約に準じます） 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"【四圣龙神录】 开源仿东方 弹幕射击游戏教程 官网（译）以及国内参考翻译资料","date":"2013-11-10T16:15:00.000Z","path":"2013/11/11/【四圣龙神录】 开源仿东方 弹幕射击游戏教程 官网（译）以及国内参考翻译资料/","text":"四圣龙神录 官网地址http://dixq.net/sr/引用doujin 上的帖子的介绍http://bbs.doujinstg.net/simple/?t1478.html #开源仿东方STG－四圣龙神录，带弹幕制作教程60讲，使用C语言+DXLib非常不错的仿东方的STG，网站上面带制作教程，可以用来参考。附带60讲教程详细介绍怎样修改他的弹幕STG工程制作弹幕。使用DxLib+C来制作 游戏截图： 游戏下载地址：http://dixq.net/zip/Ryujinroku_v2.64.zip源代码下载地址：（请注意这个源代码是他那个60讲的projects，里面包含了基本游戏本体的实现）http://dixq.net/rp/zip/project.zip60讲讲座地址（日文）：http://dixq.net/rp/游戏主页：http://dixq.net/sr/ 就是酱紫。dxlib的主页 也基本介绍了，接下来，就看看四圣龙神录的教程。 让我们离东方STG同人更近一步吧。主页本来想基本翻译一下的，不过右边的菜单大多都是汉字了，就免了吧，看的懂的。分别是【下载】【龙神录的程序馆】【龙神录论坛】【操作说明】【必要环境】【主页】【制作者HP】【nico动画】（一直在想那个HP是啥意思，不可能是生命值啊，点过去点回来，突然懂了，就是home page，主页的意思。这里作者的主页是 C语言的教程和问答板）左边的三段话，大致意思是 仿东方系列的真正的弹幕射击游戏这是敌方放出大量弹幕，需要一边细致操作一边前进的真正的弹幕射击游戏。这次加入 Phantasm OMaKe spell practice 等等（omake是啥啊）大量新元素，版本大幅更新。初学者也可以放心的使用，做出谁都可以快乐的玩的游戏。 采用图像转换引擎实现 更复杂的的弹幕可以单独生成弹幕采用了图像转换引擎，现在可以实现各种复杂和奇葩的弹幕了。游戏的时候，在 符卡练习的时候 也可以使用这个引擎，实现各种各样的弹幕。 以 Phantasm 结束的 四圣龙神录的故事这次的Phantasm 是 Full Voice操作新人物 Lilia 和主人公 Aysha 在phantasm的世界，装备上 voice 会有什么样的演出呢.上次的故事留下的谜团，会在这次的phantasm里解决吗？ 这个世界会变成什么样呢？在你的面前，将见证四圣龙神录的终极结局。 右上角 第一个 红按钮，是下载页面。点进去后，左边的按钮 就是下载，下面标明了版本和大小。v2.83 [92.9MB] 第二个按钮，是调查问卷。 注：发现国内也有些博客是参考了四圣龙神录的，所以我也参考一下他们的翻译啦。下面是参考博客资料：http://yanglefeng.iteye.com/blog/1337059http://www.cnblogs.com/tomboy/archive/2012/09/23/2588837.htmlhttp://tieba.baidu.com/p/2253884537 （突然发现百度DxLib吧好像有系列的翻译了，囧，我都写到第六章了，去看看） 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"Gnu C++ (Bloodshed Dev-C++) 上DxLib的使用方法 （渣翻译）","date":"2013-11-03T08:40:00.000Z","path":"2013/11/03/Gnu C++ (Bloodshed Dev-C++) 上DxLib的使用方法 （渣翻译）/","text":"原文地址：http://homepage2.nifty.com/natupaji/DxLib/dxuse_gcc.html由于日文原文较长，所以这里不贴原文，就大致理解，给出个人译文吧。 要在Gnu C++ 上 使用DxLib 制作软件，请按照下面的步骤进行。或者说，这里不仅是Dev-C++的使用方法，而是在Dev-C++ 上用DxLib使用的步骤。 1.要使用 DxLib所必须要准备的东西2.Dev-C++ 上，使用DxLib的设置3.项目的创建4.为了使用DxLib，而进行项目的设置5.程序的代码组织 编译项目，运行 要在Dev-C++ 上使用DxLib，需要以下的东西。 Bloodshed Dev-C++ 给Gnu C++用的DxLib版本 首先，Bloodshed Dev-C++ 是使用Gnu C++进行软件开发的使用最简单易用的软件。 这是免费公开的软件，如果电脑上没有安装Dev-C++的话，直接搜索一下，找到它的下载网址。（本说明 主要是为了说明Dev-C++的使用配置方法，所以安装教程就不讲了） 然后，Gnu C++ 版本的DxLib 可以在本站点的这里 下载到。没有这个的话，DxLib 是使用不了的，如果还没有下载的话，请先下载。 Dev-C++ 上使用DxLib 所需的设置必须的东西都准备好了之后，只要在Dev-C++上稍作设置，电脑上任意位置的项目都可以使用DxLib了。① 选择 Dev-C++ 的菜单里的Tools -》 Compiler Option② 选择 Compiler Option 窗口 的 Directorie③ 下面出来的 标签里面 选择 Libraries④ Directory List （文件夹列表） 里，添加上 DxLib的 包『プロジェクトに追加すべきファイル_GCC(Dev-cpp)用』 GCC（Dev-cpp）用的项目 添加文件夹 ) 把这个文件夹的路径，填进去 注意，要点击Add按钮，才能进行添加⑤ 现在，选择 C++ Includes 这个标签⑥ 和第四步的 文件夹列表一样，加上 『プロジェクトに追加すべきファイル_GCC(Dev-cpp)用』（GCC（Dev-cpp）用的项目添加文件夹） 这个文件夹的路径。 （注意，点击Add 按钮，才能进行添加）⑦ 点击OK 按钮，设置就完毕了。 Dev-C++ 已经设置好了的话，赶紧用DxLib制作软件吧因为主要是说使用步骤，这里就简单在画面的中心画一个点，以制作这样的程序作为说明吧用 Dev-C++ 制作 软件，首先要创建一个项目，下面就是具体方法的说明。 ① Dev-C++ 的菜单，选择 文件 -》新建-》 项目② 新建项目 窗口中，选择 windows 程序。③ 在项目 的名称一栏中，填入 项目名称，然后点击OK按钮。 （在这里就填入 DrawPixel 作为项目名）④ 然后，选择项目的保存位置文件夹，选择好了之后，点击保存按钮。⑤ 打开项目的话，最初是 示例代码，打开main.cpp 选择 Dev-C++的菜单 的 文件–》 保存，在 项目文件夹里，把main.cpp文件保存一下。 DxLib的文件往项目文件夹复制过去之后，为了要让项目使用DxLib，需要进行一些设定 ① 选择 Dev-C++ 的『Project』→『Project Options』。 ② 选择 Project Options窗口的『Parameters』标签。 ③ 『C++ compiler』这一栏，填入以下两行。 -DDX_GCC_COMPILE-DDX_NON_INLINE_ASM ④ 『Linker』项目里，填入以下13行。 -lDxLib-lDxUseCLib-lDxDrawFunc-ljpeg-lpng-lzlib-ltheora_static-lvorbis_static-lvorbisfile_static-logg_static-lbulletdynamics-lbulletcollision-lbulletmath 行的顺序改变了可能导致无法正常链接，请按照上面所述的顺序输入。⑤ 点 OK 按钮，设定就OK了 5.接下来就是代码的编写了。 Dev-C++ 的项目一开始就添加好 main.cpp 的， 因为代码是写在这里的、在 Dev-C++ 菜单的『Edit』→『Select All』选择，按Delete键全部删掉。 然后把下面的代码输入 main.cpp 。这是在画面中心画一个点的程序。 12345678910111213141516171819#include \"DxLib.h\"// 程序是从 WinMain 开始的int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )&#123; if( DxLib_Init() == -1 ) // DxLib的初始化 &#123; return -1 ; // 发生错误的话，直接退出 &#125; DrawPixel( 320 , 240 , 0xffff ) ; // 画一个点 WaitKey() ; // 等待按键输入 DxLib_End() ; // DxLib使用结束 return 0 ; // 程序结束 &#125; 程序就这么短，这里解释一下这段代码做了什么。 首先第一行是把使用DxLib所必需的文件包含进来。 然后『int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )』是windows程序的入口函数的声明。这些词语的具体是什么含义，可以不必太关心。 Windows环境下的程序的入口函数都是这样声明的。 中间括号里面的『if( !DxLib_Init() ) return -1;』是DxLib的是调用DxLib的初始化函数『DxLib_Init』。这个函数，是使用DxLib的程序，在除了特殊例外情况下，都是需要最先调用的。因为有『if(…』的判断，如果初始化失败了，那么程序就退出。 『DrawPixel』就是画一个点的函数。 然后『WaitKey』是等待按一个键的暂停函数。 最后的『DxLib_End() ;』注释上也写了，是DxLib使用结束的处理函数。使用DxLib的程序最后必须要调用这个函数。没有调用这个函数程序就结束了的话，会粗大事的，请注意。 输入完成后，运行一下吧 ① Dev-C++ 的菜单里，选『Execute』→『Compile』 ，编译程序。 编译成功的话， Compile Progress 窗口里有『Done.』来表示。 发生错误的话下面的窗口会输出错误的信息，按照上面的错误提示进行改正吧。 ② 然后 Dev-C++ 的菜单里面选择『Execute』→『Run』。程序就开始运行了 然后程序画面中心是不是生成一个点呢？ 编译生成了一个可执行文件，他在项目的文件夹下面。这就是我们目前工作的成果。 于是了解使用DxLib开发程序的方法了吧。 接下来就可以按自己想喜好编写程序，组合成一个游戏了。 但目前我们只知道DxLib的初始化，结束，和画一个点的函数。 其他的函数在DxLib的函数手册页面说明，请去那里参考一下吧。 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"DxLib","slug":"DxLib","permalink":"http://yoursite.com/tags/DxLib/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C语言/"}]},{"title":"DxLib 的使用方法 （翻译）（继续乱编）","date":"2013-11-02T05:48:00.000Z","path":"2013/11/02/DxLib 的使用方法 （翻译）（继续乱编）/","text":"原文地址：http://homepage2.nifty.com/natupaji/DxLib/dxuse.html ここではＤＸライブラリ使って実際にソフトを動かすところまでを解説します。这里是DxLib的使用方法，以及让它实际可以运行的方法的说明。 下記のソフトは無償提供されているので何も持っていない方でもＯＫ以下是免费的软件，你什么都没有也可以使用这些软件搭配起开发环境。 VisualStudio Express 2012 for Windows Desktop 的使用者请看这里 VisualC++ 2010 Express Edition 的使用者请看这里 BorlandC++ Compiler 5.5 的使用者请看这里 (比VisualC++ 轻便但缺少强大的debug功能) Gnu C++ ( Bloodshed Dev-C++ )的使用者请看这里 (适用于已经在使用 Dev-C++ ( 又称作 Gnu C++ ) ，想在这个基础上开发DxLib的朋友) こちらはソフトを購入、もしくは既に所持していないと利用できません下面的这些软件需要购买，如果你原本没有这些软件，就无法直接使用了。 VisualStudio 2012 の方はこちら VisualStudio 2010 の方はこちら VisualStudio 2008 の方はこちら VisualC++ 2008 Express Edition の方はこちら VisualStudio 2005 の方はこちら VisualC++ 2005 Express Edition の方はこちら VisualStudio .NET2003 の方はこちら(VisualC++ .NET2003 の方もこちら) VisualStudio .NET2002 の方はこちら(VisualC++ .NET2002 の方もこちら) VisualC++ 6.0の方はこちら （不用翻译了） (書いてある通りにしても上手く行かなかった場合は掲示板までご連絡ください) 如果在上面没有找到适合的开发环境，请到这个提问板 提出，谢谢。 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"DxLib","slug":"DxLib","permalink":"http://yoursite.com/tags/DxLib/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C语言/"},{"name":"游戏","slug":"游戏","permalink":"http://yoursite.com/tags/游戏/"}]},{"title":"DxLib 下载页，简单翻译（我不懂日文，瞎编的）","date":"2013-11-02T04:49:00.000Z","path":"2013/11/02/DxLib 下载页，简单翻译（我不懂日文，瞎编的）/","text":"DxLib 下载页 原文地址：http://homepage2.nifty.com/natupaji/DxLib/dxdload.html DxLib 的 下载 ここではＤＸライブラリのダウンロードが行えます。在这里可以下载到DxLib。 ダウンロードできるファイルは圧縮されています。ファイルは 自己解凍となっていますのでダウンロードしたファイルを そのままダブルクリックして下さい。すると解凍先を聞かれ ますので希望のフォルダに ＤＸライブラリ開発に必要なファイルを解凍してください。下载下来的文件，是一个压缩文件。 文件是自解压类型的，下载下来以后直接双击文件就可以了。然后，选择要解压到的文件夹，把开发所必须的文件解压出来。 ＤＸライブラリ VisualC++用(Ver3.11)をダウンロードする(自己解凍形式(約14.4MB)) ＤＸライブラリ BorlandC++用(Ver3.11)をダウンロードする(自己解凍形式(約9.8MB)) ＤＸライブラリ Gnu C++用(Ver3.11)をダウンロードする(自己解凍形式(約11.6MB)) 上面分别是三种编译器，所对应的DxLib 下载链接地址，都是自解压格式的。 ＤＸライブラリの使い方についてはこちらを参照して下さい。 開発環境の構築からソフトを実際に動かすところまでが説明されています。 ＤＸライブラリで使用できる全関数についてはこちらを参照して下さい。旧バージョンはこちらにあります。 DxLib的使用方法，请参照这里 。 从开发环境的搭建，到实际的运行，都有详细的说明。DxLib 里能使用的所有API函数等内容，请参考这里。这里可以找到早期的版本。 VisualC# 用パッケージ VisualC#でＤＸライブラリを使用するためのファイルをこっそり置いておきます。(C++言語でＤＸライブラリを使用される方は必要ありません)VisualC#用(Ver3.11) 尚、変換ソフトを使用して機械的にC#用のファイルを作成しているだけですので、C#の仕様に適した形態に整えたりはしていません。 Visual C# 用的版本 Visual C# 下可以使用的 DxLib 的文件在这里。（不需要用C++语言来 使用DxLib）。VisualC#用(Ver3.11)此外，由于是使用转换软件将其转换成C#可以用的格式，不具有C# 标准的格式。 （大概是这个意思不？） ソフトウエアレンダリング機能無しの軽量化パッケージ サイズの大きいソフトウエアレンダリング機能コードを無くしたパッケージです、コンパイルして作成される実行可能ファイルが５００ＫＢ程小さくなります。 ただ、ソフトウエアレンダリング機能コードが無いと正常に動作しない環境も世の中にはまだありますので、 作成するソフトとターゲットとする実行環境の見極めをした上で必要な方はお使い下さい。 去除掉软件渲染功能的简化包。 这是把比较大的软件渲染功能去掉的软件包，压缩下来可以可以缩小500KB左右。但是（大家知道要说啥意思了的吧），去掉软件渲染可能在有些环境下无法正常工作，请确认要制作的软件和目标运行环境后，采取选择对应的版本。下面是，去掉软件渲染的压缩版本。（如可能无法正常工作，请使用完整版） VisualC++用(Ver3.11)BorlandC++用(Ver3.11)Gnu C++( Dev-cpp )用(Ver3.11)Gnu C++( MinGW )用(Ver3.11) 使用例 ・作成するソフトがそれなりの性能を持ったグラフィックスデバイスが必要な程重いので、動作速度の遅いソフトウエアレンダリング機能ではそもそもゲームにならない・お遊びで作るミニゲームだから実行ファイルはなるべく小さくしたい 使用示例~制作出的软件，都是在高性能的图像设备上运行的，运行速度迟缓的软件渲染功能，在游戏里本来就是不需要的。~我在做娱乐用的迷你游戏，所以想让可执行文件更小一些。 改造希望の方へ ＤＸライブラリはオープンソースで、改造もＯＫ、と言っておきながら現在はＬＩＢ形式での配布となり 改造が非常に行い難くなってしまいました。 ので、プロジェクトを開いてビルドするだけでＤＸライブラリの核であるDxLib.lib ファイルが 作成されるプロジェクトフォルダを丸ごと圧縮したものをここにアップします。 ＤＸライブラリ(Ver3.11)のプロジェクトをダウンロードする(自己解凍形式(約1.48MB)) 尚、ＤＸライブラリのコンパイルには Borland C++ Compiler 版のみ C++ BuilderX 付属のコンパイラ以降のバージョンでないと正常にコンパイルすることが出来ませんのでご注意ください。 可能的改进方案 虽然说 DxLib 是开源的，可以允许修改，但目前是以Lib的形式发布的，所以修改起来是很困难的。 所以，在打开项目后只需要了 build 就能生成的 DxLib.lib 文件的项目文件夹，直接压缩放在这里了。 DxLib(Ver3.11)项目文件下载(自解压形式(約1.48MB)) 另外，DxLib的压缩文件，是只使用 Borland C++ 编译器，没有附加 C++ BuilderX 编译器的版本，编译出来的，大家注意一下。 好了，翻译完毕，唉，谷歌沪江啥的，机翻的都是渣渣啊~ 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"DxLib","slug":"DxLib","permalink":"http://yoursite.com/tags/DxLib/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C语言/"},{"name":"游戏","slug":"游戏","permalink":"http://yoursite.com/tags/游戏/"}]},{"title":"DXLib 主页，简单翻译(我其实看不懂，都是瞎掰的）","date":"2013-11-01T18:26:00.000Z","path":"2013/11/02/DXLib 主页，简单翻译(我其实看不懂，都是瞎掰的）/","text":"原文地址：http://homepage2.nifty.com/natupaji/DxLib/ Dx Library 的小院ＤＸライブラリとは、DirectXを使ったWindowsソフトの開発に必ず付いて回るDirectXやWindows関連のプログラムを使い易くまとめた形で利用できるようにしたＣ＋＋言語用のゲームライブラリです。(使用する際はＣ言語の知識だけで大丈夫です) DxLib， 是为了在 用DirectX技术开发windows 软件时，使得必须用的DirectX和Windows程序关联的开发更加容易 的，用C++写的一个游戏库。（实际上，只要用C语言的知识也就差不多够了） これによってプログラマーはゲームの本質的なプログラムに専念することが出来ます。かなり本格的なソフト制作からお遊び程度のミニゲーム制作まで幅広くカバーしています！ 使用了这个，可以让程序员把精力更专注的放在游戏本身上。 从相当正式的软件开发，到休闲的迷你游戏的开发，都可以用它实现。 プログラムソースも公開していますので気兼ねなく使用してください。 程序的源代码也已经公开了的，请放心的使用吧。 下面这段，好像是推荐了两本教材。大概是两本简单易懂的C 语言教材。 学了C以后 有一定基础了再学C++，然后结合DxLib，就可以编写游戏了。下面的目录，大致也能看懂吧。 ＤＸライブラリ更新履歴 DxLib 更新历史 ＤＸライブラリＨＰ更新履歴 DxLib HP更新历史 （HP是个啥） ＤＸライブラリの仕様と特徴 DxLib 的功能特点 どこまでできるＤＸライブラリ DxLib 有多强大的功能呢 （里面是通过问答的形式，介绍功能特点的） ＤＸライブラリのダウンロード DxLib 的下载 ＤＸライブラリの使い方 DxLib 的使用方法 ＤＸライブラリの関数リファレンスマニュアル＆サンプルプログラム DxLib的API手册和示例程序 （感谢谷歌终于给出明确的翻译） ＤＸライブラリミニテクニック DxLib 的使用小技巧 ＤＸライブラリサンプルプログラム DxLib 的示例程序 ＤＸライブラリゲームプログラム開発講座 DxLib 游戏编程开发讲座 ＤＸライブラリサンプルゲームのダウンロード DxLib 示例游戏 下载 『皆様の作品紹介！』投稿＆閲覧ページ 【大家的作品介绍】 投稿和阅览 下面好像说了一些投稿 的东西，大概就这样了，施工完毕，喵。大家照这个目录，去主页找对应的东西吧，闪人了，喵 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"四圣龙神录","slug":"四圣龙神录","permalink":"http://yoursite.com/tags/四圣龙神录/"},{"name":"弹幕射击","slug":"弹幕射击","permalink":"http://yoursite.com/tags/弹幕射击/"},{"name":"弹幕教程","slug":"弹幕教程","permalink":"http://yoursite.com/tags/弹幕教程/"},{"name":"东方STG","slug":"东方STG","permalink":"http://yoursite.com/tags/东方STG/"}]},{"title":"用python 处理字符串，初次使用后感受","date":"2013-10-12T02:51:00.000Z","path":"2013/10/12/用python 处理字符串，初次使用后感受/","text":"这边工作上，要处理些数据，开始有些，根据老大的指示，给excel 加上对应的分隔符，直接复制过去就是字符串数组了。 不过，那边说漏了一些，某些ID根据vip 要加上些东西。这下好，蛋疼了。 去excel 把 要加的ID 整理出来，拿着原来的 列表，要搜索出哪些需要加，然后在后面的字符串加上特定的字符。 想想也简单对不，就是两次遍历，再操作字符串就是了。 Java 虽然也好用，但我还是不熟悉文件操作。都说Python 处理字符是很强的，这种工作就用python试试呗。 好吧，这么个简单的工作，从吃了晚饭后，一直整了一个晚上。下面是使用后的一些总结。 1， python 看起来是很简洁，但半生不熟的话，好多API 还是要现查，这是一个。就比如 正则，是用compile 后的去match， 还是直接 re.search ，这没有自己使用后，还是不知道其中的区别，和适用的场合。 还有各种字符串的操作，和列表的一些处理，也是学了都忘了。 2. 除去API 的不说，排版也是个问题。 都知道python 没有大括号，靠用缩进来指示层次。 我这循环，判断，写了3,4层，后面的逻辑就搞不清要放到哪一层去了。当然这是我个人编码底力不足的因素。不过，调整层次还得目测来确定各个层次的范围，一定程度上确实不如用大括号区分直观。（或许是我该配个更顺手的IDE，而不是用啥都没有的IDLE了） 3.好吧，最大的问题，昨天耗费我时间最多的问题。除了查API 了解字符串，读写文件操作，使用正则以外，更蛋疼的问题。就是文件末尾的换行符。123456789for line in data: matcher = pattern.match(line) if matcher != None: role = matcher.group(1) flag = False for vip in vips: if vip.strip() == role.strip(): // 注意这里 flag = True break 上面注释这行，就是问题所在。总算代码调通了。缩进，层次逻辑也应该改对了，可就是不出来正确的结果，为什么？newline = line[:len(line)-4]+pitch+line[len(line)-4:]这行也是，测试的时候，两个字符串放到倒数第3的位置，就对了的。为什么写文件的时候，发现插错了地方？ 一切都是因为文件每行末尾的换行符！！！ 总结一下，python 掌握常用 字符串 读写 正则的API 后，并且习惯缩进式的使用，还是挺容易处理字符串类的工作的。只是，下次多注意，换行符，这坑爹的东西啊。。。 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Ubuntu 文件夹丢失左边的侧边栏（设备 计算机 网络） 解决办法","date":"2013-08-11T08:40:00.000Z","path":"2013/08/11/Ubuntu 文件夹丢失左边的侧边栏（设备 计算机 网络） 解决办法/","text":"在折腾Unity 3D 桌面的时候，折腾完了，发现文件夹左边这一列导航栏没了。这下，要打开windows下的分区也没办法了（或者说很麻烦了） 记得在玩3D特效的时候，有个快捷键好像是改了文件夹的布局。于是重新玩了一次。找到了这个快捷键。 Shift + F9 这个快捷键，和水波特效的快捷键是冲突的，所以玩水波的时候，不小心就把文件夹的侧边栏给弄没了 这里也有人发出来解决方法了，当时我没仔细看，看回帖貌似不对就关了。http://forum.ubuntu.com.cn/viewtopic.php?p=2823249其实就在文件夹，顶上 查看菜单就可以调出侧边栏 http://www.ithov.com/linux/100024.shtml这里，有些关于怎么复制出文件夹路径的方法。没大搞明白，反正最后 Ctrl+L 貌似还挺管用的。 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}]},{"title":"Ubuntu 菜鸟遇到的问题","date":"2013-07-27T12:23:00.000Z","path":"2013/07/27/Ubuntu 菜鸟遇到的问题/","text":"硬盘安装Ubuntu http://www.linuxidc.com/Linux/2012-11/73500.htm 个人遇到file not found 的问题，除了要注意 分区0,1 的问题外，也要注意自己解压的文件后缀名的问题 http://hi.baidu.com/tidus_forever/item/29e7cc875baf94c198255f35 安装codeblocks http://blog.csdn.net/sddi1989/article/details/8627856 键盘设置快捷键，老是禁用？ http://forum.ubuntu.org.cn/viewtopic.php?t=417021 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}]},{"title":"面试时被问到的技术方面的问题","date":"2013-07-17T00:38:00.000Z","path":"2013/07/17/面试时被问到的技术方面的问题/","text":"额，面了几个月，还是没面过。总结一下被问到的一些方面。昨天面Java，被问到 List Set Map的区别。 StringBuffer 和StringBuilder的区别。 笔试上也有 HashTable 和 HashMap的区别。 虽然我都不知道。。。。字节流和字符流的转化。 反射的也会问。 多线程，会问是怎么同步的，有几种方法。怎样结束一个线程。 一个线程的生命周期。 网络，会问Socket 方面的问题。 然后线程池的问题， 一个队列，有进，有出，如何设计使它更高效。 数据库，一般都会问 Oracle 会吗，使用过吗。 当然一般都要求写一段SQL语句。 android 虽然我也是三脚猫，但貌似是想问 android Server的一些东西。 C/C++除去有一些有bug一般的面试题不说（这些要求细节比较多，也是希望进去就能上手开发）一般来说，像多线程，网络，还是和上面的类似 。面试题里一般问的是，继承里面的 static 以及 构造和析构函数的调用。然后 overload 和overwrite 的区别。struct 和 class 的区别。是不是还有一些 考察 virtual 的，虚函数，虚基类的。恩，设计模式也都会问到一些，像分哪几类，写一个 单例模式等等。 恩，虽然自我感觉数据结构了解的还行。笔试题一般也就出一个简单的排序，但面试就没这么简单了。一般可能会问算法复杂度的比较，排序也问的是二叉排序，而不是冒泡。二叉排序树（BST）删除节点的方法等。 唉，自己几个月没工作。感觉走不动了。以前工作的时候没有紧迫感，现在啥都不会了。给以后的自己一个教训。对未来没有把握，那就多学习，做好准备。特别是我上家做的外包，明知这技术外面用不到，还是混一天是一天，直到混不动。（还天真的以为一直会这样混下去）开始找工作的时候，也是眼光太高，没大量的投。结果错过了3,4月份最好的时机，也没看到知名的企业在招。后来天气也热起来了，而且不频繁面试的话，一周一周，一个月一个月就这么过去了。再混下去，都到8月了，天气都转凉了，要混4个月了。。。 华为又涨工资了，唉，后悔当初没去华为啊，现在想去也去不了。。。。唉，求华为收留吧。本来想着，去了，有所得，有所失。不去的话，也能有所得。结果，目前看来，我还是不如就在里面混好些。学得到技术（或者说干软件行业的某种能力），挣得到钱（在中国，这就是基本解决了绝大部分问题），只是人可能会变得比较呆板，古板，木讷，然后身体累坏好几年。不在里面，能自己干想干的技术，做想做的事，拥有的是自由。恩，再想想，一专和多能的关系。小公司里的大牛什么技术都会，比起在大公司，只是钻研某方面的技术。到底哪个好，也说不清。记得，第一个小公司的师兄说，在华为这样的公司，干的就是重复拧螺丝的活，对其他的都不了解。记得，离职的时候，boss是从华为过来的，我说要在华为干，得技术好，能吃苦能加班，是吧。他说，不，在华为最重要的，是服从命令。恩还是那句话，就我的个性而言，去华为说不定是最适合的。求收留啊。。。。 以前看同事努力工作，不知道为什么要这么卖命，现在看来，不努力，就会没有工作啊。小公司往往要求的技术细节多，大公司只要基本的都知道就行了 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"个人工作","slug":"个人工作","permalink":"http://yoursite.com/tags/个人工作/"}]},{"title":"libgdx 的 FreeTypeFontGenerator在android项目下的使用","date":"2013-07-08T16:42:00.000Z","path":"2013/07/09/libgdx 的 FreeTypeFontGenerator在android项目下的使用/","text":"桌面版，使用FreeTypeFontGenerator 没什么问题，但android项目老是报错。网上搜了一下解决方案，把jar什么的包含了进去，还是有些问题。这里把解决的方案大致写上来。 首先，参考这里：http://www.badlogicgames.com/wordpress/?p=2300把 gdx-freetype.jar 复制到libs下， 包含到android 项目中。然后在 build path 的order and export 把勾打上。 带有native的是给桌面版项目用的，android项目不需要。 android项目需要的是 .so 文件。去libgdx的 gdx-freetype 文件夹下， 把armeabi 和 armeabi-v7a 复制到libs下，和原来的这两个目录合并。还有一些问题。额，新建了一个项目验证，才解决掉。就是，TTF 字体文件名是区分大小写的。若文件名是 font.TTF 代码用的是 font.ttf 是会出错滴。。。。 就这个了。 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"libgdx","slug":"libgdx","permalink":"http://yoursite.com/tags/libgdx/"}]},{"title":"Git 仓库中删除大文件的历史提交记录","date":"2013-04-08T01:03:00.000Z","path":"2013/04/08/Git 仓库中删除大文件的历史提交记录/","text":"刚接触这东西，会使用GitHub for windows 之后，感觉挺好用的。不过最近发现，代码库已经有90M大小了。想一想，除了把ttf字体文件提交了之外，图片素材，和编译后的class文件都提交了。网上找一些方法，删除历史记录。综合一下，总算成功了。 官方教程：https://help.github.com/articles/remove-sensitive-data相关教程：http://yihui.name/cn/2010/12/animation-update-1-1-5/http://www.azhowto.com/removing-sensitive-data-from-git/其中要填的是路径。官方教程里就位于根目录，所以直接写的文件名。上面还提到了，windows下要用双引号。(其实后来发现单引号也行）路径分隔符，要使用斜杠 / 可以这样，删除生成文件。git filter-branch –force –index-filter “git rm –cached –ignore-unmatch ./myproject/bins/*” –prune-empty –tag-name-filter cat HEAD – –all PS：又试了几下，上面的命令好像有些问题了，也可以用这条命令git filter-branch –force –index-filter “git rm –cached –ignore-unmatch *.jar” HEAD – –all 官方教程里的命令好像有点问题，在 cat 后面少了个 HEAD参考网上的一些资料，最后我用的是这样的命令git filter-branch –force –index-filter ‘git rm –cached –ignore-unmatch *.class’ –prune-empty –tag-name-filter cat HEAD – –all 然后 按照Animation 文章里面的，运行后面几条命令，把改动push 到远端服务器上。然后把本地历史文件也情况，这下 du -sh 就看到文件夹已经只有 100多K 了 12345git push origin master --forcerm -Force -R .git/refs/original/git reflog expire --expire=now --allgit gc --prune=nowgit gc --aggressive --prune=now PS： 某处看到的，添加到 .gitignore 之后，有些文件还是被跟踪了，因为这些文件已经被 add了。 只要 git rm 这些文件，ignore 列表就生效了。git rm –cached git rm会本地删除文件，并取消git的跟踪。 用 git rm –cached 可以本地不删除，并取消git 的跟踪。然后 commit 就好啦 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"github merge tool 可视化的合并工具","date":"2013-04-06T15:27:00.000Z","path":"2013/04/06/github merge tool 可视化的合并工具/","text":"在另外一台机子上改了代码，回来后，发现同步出了问题，也就是有冲突了。用SVN的话，还直观一些。 可 GitHub for windows 没有提供可视化的解决冲突的界面，只会说同步失败，然后建立一个detached Head 的分支，让自己解决冲突去。 查了一晚上，找了一些相关的问题解决方法。git status ，提示有一些文件 merge 失败，其实就是冲突了。git mergetool 的时候，提示 C:\\program files\\.. 下的 bcomp.exe 找不到。 这其实就是默认设置成 beyond compare的路径，然后这里没找到对应的文件。我这好像装了某个版本的beyond compare ，这东西确实比较好用。设置的话，经google 查找 git mergetool beyondcompare 找到介绍。 对于windows 用户： Windows users can configure this by entering the commands: git config --global diff.tool bc3 git config --global difftool.bc3.path &quot;C:\\Program Files (x86)\\Beyond Compare 3\\BComp.exe&quot;上面就是用命令，把bc3 改成 diff 的工具下面是配置文件，直接改这个文件，效果一样的。在我这，路径应该是 C:\\Users\\用户名.gitconfig ###Windows notepad C:\\Program Files\\git\\etc\\config [user] name = First Last email = &lt;a href=&quot;mailto:email@address.com&quot;&gt;email@address.com&lt;/a&gt; [color] ui = true [core] editor = nano [merge] tool = bc3 [mergetool &quot;bc3&quot;] cmd = &apos;C:\\Program Files (x86)\\Beyond Compare 3\\BComp.exe&apos; \\ &quot;$PWD/$LOCAL&quot; \\ &quot;$PWD/$REMOTE&quot; \\ &quot;$PWD/$BASE&quot; \\ &quot;$PWD/$MERGED&quot; keepBackup = false trustExitCode = false设置好之后，git mergetool 就可以用beyond compare的GUI 来显示合并了，看起来舒服多了。 PS： 用 git gui 也不错，但那个没用过，看不大懂。 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"android adb is down","date":"2013-01-08T15:46:00.000Z","path":"2013/01/08/android adb is down/","text":"The connection to adb is down, and a severe error has occured. You must restart adb and Eclipse. Please ensure that adb is correctly located at ‘D:\\program files\\Android\\android-sdk\\platform-tools\\adb.exe’ and can be executed. 当运行android 程序，出现以上提示的时候当查遍网上的攻略，设置环境变量，检查android-sdk， 结束adb 进程，关闭豌豆荚 然后adb kill-server adb start-server各种方法试了都不行的时候请去project 的 Run As – Run Configuration 切换到 Target 找到下面自己创建的 AVD 打个勾，然后Run 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"CodeBlocks 10.05 配置DxLib v3.09","date":"2012-12-02T14:55:00.000Z","path":"2012/12/02/CodeBlocks 10.05 配置DxLib v3.09/","text":"从自己的百度空间搬过来的。出于对东方的喜爱，也想学习弹幕游戏的设计。之前看到一个教程，四圣龙神录， 是一个开源仿东方的弹幕游戏教程。60讲讲座地址（日文）：http://dixq.net/rp/游戏主页：http://dixq.net/sr/ 看上去相当不错啊，有这样的教程，至少不会感觉摸不到门了，不知从何学起。四圣龙神录的教程，用的是C语言和DxLib库写的。DxLib 是日本同人界广泛使用的开源游戏引擎，相当于给DX重新打包编译的版本。 这是DxLib的主页http://homepage2.nifty.com/natupaji/DxLib/index.html想学习一下DxLib的使用，就去官网上下了，想配置好，学习一下。下载页面：ＤＸライブラリのダウンロード使用方法：ＤＸライブラリの使い方下面那个 是手册和示例：ＤＸライブラリの関数リファレンスマニュアル ＆ サンプルプログラム 去下载页面，就可以看到下载链接。因为我是想配置到Codeblocks上，使用的是MinGW编译器，所以选择ＤＸライブラリ Gnu C++用(Ver3.09)をダウンロードする(自己解凍形式(約10.2MB))下下来的文件是 DxLib_GCC3_09.exe 下面那个ソフトウエアレンダリング機能無しの軽量化パッケージ好像是说 没有Software Rendering ，也就是没有软件渲染的版本。下下来的文件是 DxLibNoneSoftDrawCode_GCC_MinGW_3_09.exe那几个下载和上面的版本，大体上是一样的，只是 libDxDrawFunc.a 文件有区别，精简了软件渲染的功能。 再下面那个ＤＸライブラリ(Ver3.09)のプロジェクトをダウンロードする(自己解凍形式(約1.39MB))好像是 DxLib 项目的打包下载链接，文件名是 DxLibMake3_09.exe 里面有一个VC6 的project，应该是自己编译 DxLib 用的。 然后来到使用方法的页面，可以从主页过去，也可以点刚才下载页里的ＤＸライブラリの使い方についてはこちらを参照して下さい 配置方法：因为是MinGW 的GCC 编译器，所以就只看这个链接的页面Gnu C++ ( Bloodshed Dev-C++ )の方はこちら (既に Dev-C++ ( 又は Gnu C++ ) を使っていて、その環境でＤＸライブラリを使いたいという方向け) 这个页面是以 Dev-C++ 作为介绍的。Dev C++ 我以前也经常用，简单轻便。不爽的就是每次最后都要暂停，不然看不到cmd窗口的显示。配置方法基本上都能看懂吧。看不懂的话， 这里也已经有人写了教程了。http://yanglefeng.iteye.com/blog/1337059十分感谢，这教程也给了我很多指引。好了，问题是Codeblocks，按照类似Dev C++这样的配置编不了，这怎么办呢？ 我就直接写最终解决方法吧，略去中间遇到的一些问题。首先，Codeblocks 10.05 有自带编译器的版本，那个自带的MinGW是编不过DxLib的。所以，要去另外下载一个MinGW。Codeblocks 里面采用的，并不是官方的MinGW，而是 tdm-MinGW。可以参考：http://wenku.baidu.com/view/3781680302020740be1e9ba0.html注意文档中，官方MinGW 和 Codeblocks 所使用的MinGW的区别，用红字标注的关于sjlj 的功能，正是这个导致DxLib编不过的原因。我1. 下载TDM-GCC下载页面：http://tdm-gcc.tdragon.net/download我下的是，左上角的 tdm-gcc-4.7.1-2.exe运行，Create一个，自己制定一个位置，选择Asia - Taiwan NCU ,然后配置编译器的时候，选择MinGW Stable, C/C++，Install 安装主要是，下面Version里有三个选项，第一个是Stable 4.7.0 -1 ,就选用这个。第二个是默认的，with sjlj ，这个是编不过的DxLib的第三个是dw2的，应该能编过，不过他的bin 文件夹里面命名比较特殊，要自己修改一下。2. 配置Codeblocks装好了编译器，就可以配置codeblocks了。2.1把Codeblocks 的编译器，设置到刚才装的MinGW Stable 文件夹。设置方法不多说了吧，setting -compiler and debugger ,下面有很多标签，切换到Toolchain Executables 设置 下面的路径就OK了。 2.2恩，然后，还是刚刚的那个设置页面，切换到Search directories ，在下面Compiler 下，点Add，按照DxLib 配置页面里讲的，把下载后，双击解压的DxLib_GCC 下面的プロジェクトに追加すべきファイル_GCC(MinGW)这个文件夹路径填进去。可以自己给他改个简短的名字。比如，我最后设置好是这样的。 2.3然后，Linker 下也Add ，加上这个路径。 顺便一说，这个页面下面的勾，可以都不用打上。有些打上可能会多一些警告或者错误。 3. 建立项目 点击 File - New -Project 选择 Win32 GUI Project，Next 选Frame Based ，设置一个保存的地方， Finish。右键点击刚建立的项目 ，选择Build Option。然后，点击左上角Debug 和Release上面的项目名称，（这样做的修改是对Debug 和Release 都有效的）点Linker Settings ，按照教程，在右边填入以下内容。 -lDxLib-lDxUseCLib-lDxDrawFunc-ljpeg-lpng-lzlib-ltheora_static-lvorbis_static-lvorbisfile_static-logg_static-lbulletdynamics-lbulletcollision-lbulletmath 切换到Compiler Setting ， 选择下面的 Other Option ，填入-DDX_GCC_COMPILE-DDX_NON_INLINE_ASM（其实，这个如果不填，到main.cpp 里面开头写上#define DX_GCC_COMPILE 和 #define DX_NON_INLINE_ASM ，效果也是一样的） 恩，接下来，把main.cpp 的内容替换为 12345678910111213141516171819202122#include \"DxLib.h\"#define DX_GCC_COMPILE// プログラムは WinMain から始まりますint WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )&#123; ChangeWindowMode(TRUE);//以窗口模式运行 if( DxLib_Init() == -1 ) // ＤＸライブラリ初期化処理 &#123; return -1 ; // エラーが起きたら直ちに終了 &#125; DrawPixel( 320 , 240 , 0xffff ) ; // 点を打つ WaitKey() ; // キー入力待ち DxLib_End() ; // ＤＸライブラリ使用の終了処理 return 0 ; // ソフトの終了 &#125; 编译运行，应该就可以了。 补充：1 编译运行，结果有个cmd 窗口，那是因为是 Debug 模式，切换到Release 模式就没有了。（就在工具栏那里，选一下）2编译有很多警告，可能是因为 project 的 build option 里面，选上了 -Wall 这个选项的原因，去掉这个勾就好了。 3 如果出现，cannot find -lDxLib 等等， 应该是漏掉了 步骤2.3 。 我写的时候，就漏了这个。。。4 如果出现 undefined reference to `_Unwind_Resume’ 是MinGW 选错了，重新选安装的Stable 版本的MinGW 就好了。 参考的文章链接，感谢：http://yanglefeng.iteye.com/blog/1337059http://moge32.jugem.jp/?eid=136http://orumin.blogspot.com/2012/07/mingw-dxlib.htmlhttp://dixq.net/forum/viewtopic.php?f=3&amp;t=10779http://hpcgi2.nifty.com/natupaji/bbs/patio.cgi?mode=view&amp;no=2232 我的个人博客地址： http://tidus5.github.io 我的CSDN博客目录： http://blog.csdn.net/tidus5","tags":[{"name":"CodeBlocks","slug":"CodeBlocks","permalink":"http://yoursite.com/tags/CodeBlocks/"},{"name":"DxLib","slug":"DxLib","permalink":"http://yoursite.com/tags/DxLib/"},{"name":"MinGW","slug":"MinGW","permalink":"http://yoursite.com/tags/MinGW/"}]}]